<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Porting </title>
</head>

<body bgcolor="#8C9CB5" text="#000000" vlink="#0000FF">

<p>&nbsp;</p>
<div align="center"><center>

<table border="1" cellpadding="30" width="70%" bgcolor="#FFFFFF">
    <tr>
        <td><div align="center"><center><table border="0"
        width="100%">
            <tr>
                <td bgcolor="#FFFFFF"><div align="center"><center><table
                border="0" cellpadding="10" cellspacing="0"
                width="100%">
                    <tr>
                        <td valign="top" colspan="2"
                        background="gate-of-consciousness.jpg"><table
                        border="0" width="100%">
                            <tr>
                                <td><font color="#FFFFFF"
                                size="7" face="Impact">Porting
                                Shen</font></td>
                                <td><p align="right"><font
                                color="#FFFFFF">copyright Mark
                                Tarver <br>
                                10/8/2011</font></p>
                                </td>
                            </tr>
                        </table>
                        </td>
                    </tr>
                </table>
                </center></div></td>
            </tr>
        </table>
        </center></div><div align="center"><center><table
        border="0" width="100%">
            <tr>
                <td colspan="2"><hr>
                </td>
            </tr>
        </table>
        </center></div><div align="right"><table border="1"
        width="100%">
            <tr>
                <td><img src="shen.gif" width="257" height="266"><p
                align="center"><font size="2"><em>Chinese
                characters for 'shen' meaning 'spirit'</em></font></p>
                </td>
                <td width="100%"><blockquote>
                    <p><a href="#What is in Your Download"><font
                    size="2" face="Verdana">What is in Your
                    Download</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Setting Up a Port of Shen"><font
                    size="2" face="Verdana">Setting Up a Port of
                    Shen : a step by step guide</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Setting Up the Primitives"><font
                    size="2" face="Verdana">Setting Up the
                    Primitive Instruction Set</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a
                    href="#Coping With Innocent Symbols"><font
                    size="2" face="Verdana">Coping with Innocent
                    Symbols</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Unwelcome Symbols"><font
                    size="2" face="Verdana">Unwelcome Symbols</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Single Namespace Languages"><font
                    size="2" face="Verdana">Compiling into Single
                    Namespace Languages</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Tail Recursion Optimisation"><font
                    size="2" face="Verdana">Tail Recursion
                    Optimisation</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a
                    href="#Currying and Partial Applications"><font
                    size="2" face="Verdana">Currying and Partial
                    Applications</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Optimising your Port"><font
                    size="2" face="Verdana">Optimising your Port</font></a></p>
                </blockquote>
                </td>
            </tr>
        </table>
        </div><p align="left"><a name="What is in Your Download"></a><font
        size="3" face="Verdana"><strong>What is in Your Download</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The Shen
        folder is shown here under Windows 7. It contains all the
        materials for Shen. The document you are reading is in
        the folder <strong>Porting Instructions</strong>. This
        document explains what you need to do to port Shen to
        your platform.</font></p>
        <p align="left"><font size="2" face="Verdana">When you
        download Shen you will see a directory like this.</font></p>
        <p align="left"><font size="2" face="Verdana">Test
        Programs ... programs for testing your port<br>
        Benchmarks ...... programs for benchmarking your port<br>
        Shen Sources ... sources for Shen in Shen<br>
        Porting ............ how to port Shen<br>
        Platforms ......... various versions of Shen under
        different platforms<br>
        License ........... the license in full<br>
        K Lambda ........ K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> code files</font></p>
        <p align="left"><img src="portin1.jpg" width="800"
        height="498"></p>
        <p align="left"><a name="Setting Up a Port of Shen"></a><font
        size="3" face="Verdana"><strong>Setting Up a Port of
        Shen: a step by step guide</strong></font></p>
        <p align="left"><font size="3" face="Verdana">1. Create a
        Folder for your Work</font></p>
        <p align="left"><font size="2" face="Verdana">Open the
        folder <strong>Platforms</strong> and see first if your
        platform is supported. As of August 2011, only CLisp is
        supported, but you may find when you open this folder
        there are many more platforms. If yours is one of them,
        your task ends here. If not, create a folder named after
        your platform which we will call <strong>Blub</strong>.
        This is your work folder.</font></p>
        <p align="left"><font size="3" face="Verdana">2. Create
        and/or Copy the KLambda Files</font></p>
        <p align="left"><font size="2" face="Verdana">The folder
        KLambda contains all the K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">
        files for building Shen. Copy these files into your Blub
        folder.</font></p>
        <p align="left"><font size="3" face="Verdana">3. Create a
        File of Blub Code: 'primitives.blub'</font></p>
        <p align="left"><font size="2" face="Verdana">Your task
        is to map the code in the K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">
        files into the Blub language. Copy the</font><font
        size="3" face="Verdana"> </font><font size="2"
        face="Verdana">K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> files into the Blub folder.</font><font
        size="3" face="Verdana"> </font><font size="2"
        face="Verdana">Your first task is to encode the
        primitives of Shen and K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">.
        Create a file primitives.blub to do that and place your
        encoding in it.</font></p>
        <p align="left"><font size="3" face="Verdana">4. Create a
        File for Mapping K</font><font size="3" face="Symbol">l</font><font
        size="3" face="Verdana"> to Blub: 'backend.blub'</font></p>
        <p align="left"><font size="2" face="Verdana">Create a
        Blub file which maps any K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">
        expression into Blub; this is your backend. Call it <strong>backend.blub</strong>.</font></p>
        <p align="left"><font size="3" face="Verdana">5. Generate
        the Blub Files Using the Backend</font></p>
        <p align="left"><font size="2" face="Verdana">Now
        generate the Blub files by running the K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> files through your backend. </font></p>
        <p align="left"><font size="3" face="Verdana">6. Create
        an Installation File</font></p>
        <p align="left"><font size="2" face="Verdana">Create a
        file install.blub which loads the primitives.blub file
        and the generated Blub files into Blub. If Blub allows
        you to save a working image after installation then save
        it. This is convenient for the user. If not, then the
        user will have to run the installation program to call up
        Shen under Blub. </font></p>
        <p align="left"><font size="2" face="Verdana">This is a
        good place to set some platform-specific values. By
        convention we distinguish between different releases of
        Shen and different releases on the same platform. This is
        important because changes in Shen source occur
        independently from changes to the port which may only
        involve backend changes to improve performance and
        eliminate errors. If you wish to distribute your version,
        you may from time to time, have to update the release to
        accomodate the latest features. </font></p>
        <p align="left"><font size="2" face="Verdana">To name
        your version, create the globals <strong>*implementation*</strong>,
        <strong>*language*</strong>, <strong>*port* </strong>and <strong>*porters*</strong>
        in your installation routine and set them as follows.</font></p>
        <p align="left"><font size="2" face="Verdana">1. <strong>*language*
        </strong>to a string naming your native host e.g.
        &quot;Scheme&quot;, &quot;Python&quot; etc.<br>
        2. <strong>*implementation* </strong>to the string naming
        your specific implementation of the language
        &quot;CLisp&quot;, &quot;SBCL&quot;, &quot;Chicken
        Scheme&quot; etc.<br>
        3. <strong>*port*</strong> to the version of your port.
        For the first port, &quot;1.0&quot; would be an obvious
        choice.<br>
        4. <strong>*porters*</strong> to you and your coworkers;
        e.g. &quot;Uncle Tom Cobbley and All&quot;</font></p>
        <p align="left"><font size="2" face="Verdana">Leave the <strong>*version*</strong>
        global alone; it reflects the actual version of Shen
        used.</font></p>
        <p align="left"><font size="3" face="Verdana">7. Test
        Your Port and Benchmark it</font></p>
        <p align="left"><font size="2" face="Verdana">The folder
        Test Programs contains a test suite for your port. Use it
        to check it works. Use the Benchmark folder to test your
        performance.</font></p>
        <p align="left"><font size="3" face="Verdana">8. Create a
        README File</font></p>
        <p align="left"><font size="2" face="Verdana">Supposing
        the port is good, create a README file detailing anything
        the user needs to know e.g. how to install Shen under
        Blub. Put your name on this folder. </font></p>
        <p align="left"><font size="3" face="Verdana">9. Clean Up
        the Blub Folder</font></p>
        <p align="left"><font size="2" face="Verdana">Remove all
        the K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> files from the Blub folder and
        anything not needed to run the installation. Don't forget
        to include the Shen license file in your folder and on
        your code.</font></p>
        <p align="left"><font size="3" face="Verdana">10. Send it
        to Us if You Want</font></p>
        <p align="left"><font size="2" face="Verdana">If you want
        to share the code, send it to me at Lambda Associates </font><a
        href="mailto:(dr.mtarver@gmail.com"><font size="2"
        face="Verdana">(dr.mtarver@gmail.com</font></a><font
        size="2" face="Verdana">). </font></p>
        <p align="left"><font size="2" face="Verdana">That's all
        there is to it. What follows is advice.</font></p>
        <p align="left"><a name="Setting Up the Primitives"></a><font
        size="3" face="Verdana"><strong>Setting Up the Primitive
        Instruction Set</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Finding
        correlates for K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> primitives is the first step in
        porting. There are currently 46 primitive functions
        needed to implement K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana">.</font></p>
        <p align="left"><font size="2" face="Verdana">With luck,
        all of these primitives will find a direct expression in
        your platform. If not you can still get through by taking
        advantage of the interdefinability of some of these
        operations. </font></p>
        <p align="left"><font size="2" face="Verdana">All the
        boolean operations are reducible to a single operation of
        which perhaps the most obvious is if. Here are the
        definitions.</font></p>
        <p align="left"><font size="2" face="Verdana">(or P Q) =
        (if P true Q)<br>
        (and P Q) = (if P Q false)<br>
        (cond (P Q) ... R ...) = (if P Q (cond ... R ...))<br>
        (cond) = (simple-error &quot;condition failure&quot;)</font></p>
        <p align="left"><font size="2" face="Verdana">The
        definitions cannot be represented by a <strong>defun</strong>
        since these operations depend essentially on call-by-need
        evaluation and not strict applicative evaluation that is
        the Shen/K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> default. Hence they are not
        defined in the Shen source code. However, if you wish,
        you can get reduce this set by compiling out the ors,
        ands, and conds in your backend in favour of if. This
        reduces your requirement to 1 primitive boolean operation
        and the target size to 37 functions.</font></p>
        <p align="left"><font size="2" face="Verdana">The next
        interdefinable group is <strong>freeze</strong>, <strong>let</strong>
        and <strong>lambda</strong>. The pivot here is <strong>lambda</strong>
        which can be used to define the other two. </font></p>
        <p align="left"><font size="2" face="Verdana">(let X Y Z)
        = ((lambda X Z) Y)<br>
        (freeze Z) = (lambda V Z) where V is fresh</font></p>
        <p align="left"><font size="2" face="Verdana">Again these
        definitions cannot be defined in K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">
        because they require non-applicative evaluation; but
        again these definitions can be used in your backend to
        compile away references to local assignments and
        freezing. Note if you use the second definition then the
        definition of <strong>thaw</strong> is</font></p>
        <p align="left"><font size="2" face="Verdana">(define
        thaw <br>
        </font><font color="#FFFFFF" size="2" face="Verdana">ffff</font><font
        size="2" face="Verdana">X -&gt; (X 0))</font></p>
        <p align="left"><font size="2" face="Verdana">(the zero
        is discarded). If your platform supports zero-place
        lambda functions then (freeze Z) = (lambda () Z) and the
        source code definition of <strong>thaw</strong> can be
        used. This reduces your requirement to 35 functions.</font></p>
        <p align="left"><font size="2" face="Verdana">The maths
        section can be pruned. In principle one can get down to
        +, - and &gt; since all the rest are definable in an
        obvious way. &gt; is not easily definable if floating
        numbers are involved and needs to be primitive. + and -
        can themselves be defined in terms of a primitive
        successor function but this is very inefficient. </font></p>
        <p align="left"><font size="2" face="Verdana">One trick
        for pruning the primitives number?, cons?, string? is to
        use <strong>characteristic</strong> functions to serve as
        the basis for recognisors. A function f is characteristic
        for a set S if f is a total function on S and for all x,
        if ~ (x </font><font size="2" face="Symbol">e</font><font
        size="2" face="Verdana"> S) then (f x) is undefined. A
        example is multiplication by 1, which is characteristic
        for numbers. This leads to a simple recognisor </font><font
        size="2" face="Symbol">r</font><font size="2"
        face="Verdana"> for S; namely (</font><font size="2"
        face="Symbol">r</font><font size="2" face="Verdana"> x) =
        true if (f x) is defined and (</font><font size="2"
        face="Symbol">r</font><font size="2" face="Verdana"> x) =
        false if (f x) is not defined. Thus for <strong>cons?</strong>
        (non-empty list test) the definition is</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        cons?<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>[] -&gt; false<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>X -&gt; (trap-error (do (hd X)
        true) (/. E false)))</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        approach is elegant but is predicated on exception
        handling which many platforms do not support efficiently.
        Hence although this model was pursued in an prerelease
        version of Shen, it was not continued.</font></p>
        <p align="left"><font size="2" face="Verdana">So in
        principle K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> can be captured in less than 35
        functions. Whether or not you use these equivalences
        really depends on the resources of your platform.</font></p>
        <p align="left"><a name="Coping With Innocent Symbols"></a><font
        size="3" face="Verdana"><strong>Coping with Innocent
        Symbols</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Languages
        from the Lisp family - which includes Common Lisp,
        Scheme, New Lisp, Qi and Clojure - support symbols as
        first class data-objects that can be passed as arguments
        to functions and returned as values. In languages like
        Python, there are no symbols in this role, whatever is
        done by symbols must be done by strings.</font></p>
        <p align="left"><font size="2" face="Verdana">Read
        carefully the section on the semantics of symbols in the
        Shen spec.</font></p>
        <p align="left"><font size="2" face="Verdana">We refer to
        symbols that are used to self-denote, rather than to
        refer to functions or other values, as <strong>innocent
        symbols</strong>. Thus in the list [John put the car into
        reverse] the symbol 'reverse' is innocent, but in (map
        reverse [[1 2] [3 4]]), the symbol denotes a function. If
        the platform language does not follow the Lisp tradition
        of allowing symbols to have semantic ambiguity depending
        on context, then innocent symbols must be created or
        simulated in the platform language. There are two
        challenges.</font></p>
        <p align="left"><font size="2" face="Verdana">1. How to
        represent innocent symbols?<br>
        2. How to recognise when a symbol should be treated as
        innocent and when not?</font></p>
        <p align="left"><font size="2" face="Verdana">Let us deal
        with these issues in turn.</font></p>
        <p align="left"><font size="2" face="Verdana">If a symbol
        occurs immediately after an opening parenthesis, it must
        denote a function and should be parsed as such. If it
        occurs within a list or as an argument to a function it
        should be parsed as an innocent symbol.</font></p>
        <p align="left"><font size="2" face="Verdana">You should
        read up in the Shen specification about non-standard
        vectors and print vectors. Essentially if innocent
        symbols are missing from the platform language, we
        recommend using <strong>print vectors</strong> to encode
        them. An innocent symbol is therefore representable as a
        print vector composed of two elements; a function called
        (e.g) <strong>print-symbol</strong> and a string
        representation of the symbol. </font></p>
        <p align="left"><a name="Unwelcome Symbols"></a><font
        size="3" face="Verdana"><strong> Unwelcome Symbols</strong></font></p>
        <p align="left"><font size="2" face="Verdana">An <strong>unwelcome
        symbol</strong> is a symbol which is couched in a
        character set that the platform will not accept. For
        instance in many languages, including ML and Prolog, the
        minus sign is an <strong>unwelcome character</strong> -
        it cannot be used within a function name although the
        underscore _ can be used. How should these symbols be
        handled?</font></p>
        <p align="left"><font size="2" face="Verdana">The
        unwelcome symbol must be mapped into a welcome symbol.
        This is best done by uniformly replacing the unwelcome
        characters by some other characters by reprogramming the <strong>intern</strong>
        function. If you intern &quot;element?&quot; to
        element_question_mark, then the user who types [element?]
        will return [element_question_mark]. You should program
        the printer to disguise this shift by programming it to
        print &quot;element_question_mark&quot; as
        &quot;element?&quot;. Look at the file printer.shen for
        an example of how this is done for Common Lisp.</font></p>
        <p align="left"><font size="2" face="Verdana">Note that
        you may have to change some of the recognisors in the
        Shen code. Shen-YACC for instance expects &lt; ... &gt;
        to flank non-terminals. Similarly you will have to work
        through the K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> files and replace the offending
        symbols according to your scheme. You will of course, not
        do that by hand, but write a program to do that.</font></p>
        <p align="left"><font size="2" face="Verdana">A similar
        technique can be used to <strong>name clashes</strong>;
        these occur when the identifier used to name a system
        function in Shen is the same as one used to name a
        different function in the platform. The trick is, of
        course, to capture these clashes and rename the offending
        symbol to the internal version which is used. This can be
        done either by the backend or within the <strong>intern</strong>
        function.</font></p>
        <p align="left"><font size="2" face="Verdana">Again you
        should program the printer to disguise this shift.</font></p>
        <p align="left"><a name="Single Namespace Languages"></a><font
        size="3" face="Verdana"><strong>Compiling into Single
        Namespace Languages</strong></font></p>
        <p align="left"><font size="2" face="Verdana">As
        observed, Shen and K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> are dual namespace languages.
        This creates a problem when compiling into single
        namespace languages. In general there is no observable
        difference between the two unless the user enters a
        global with the same identifier as a function or vice
        versa. In that case in a single namespace language,
        overwriting occurs and in a dual it does not.</font></p>
        <p align="left"><font size="2" face="Verdana">In general
        single and dual namespace languages are observationally
        equivalent as long as the space of function identifiers
        and global identifiers are kept disjoint. Such a regime
        is easily maintained in 99% of all cases by simply
        checking to see if the identifier is bound to a function
        (<strong>fbound?</strong> function test in Shen) if it is
        to be used as a global or a global (<strong>bound?</strong>
        function test in Shen) if used as a function and issuing
        an error if this is the case. </font></p>
        <p align="left"><font size="2" face="Verdana">Rather more
        difficult are the 1% of cases where the global assignment
        is dynamically made and the identity of the global is not
        known at compile time. This function does exactly that.</font></p>
        <p align="left"><font size="2" face="Verdana">(define
        dynamically-set <br>
        </font><font color="#FFFFFF" size="2" face="Verdana">zzzz</font><font
        size="2" face="Verdana">X Y -&gt; (set X Y))</font></p>
        <p align="left"><font size="2" face="Verdana">Here
        (dynamically-set (hd [hd]) 0) will set hd to 0. In a dual
        namespace this will cause no problem, but in a single
        namespace it will raise an error or likely cause the
        system to crash. Let us then consider how Shen and K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> can be compiled into a single namespace
        language.</font></p>
        <p align="left"><font size="2" face="Verdana">If the
        language does not support innocent symbols then the
        likeliest strategy is to parse innocent symbols into
        print vectors in the manner described in the previous
        section. In this case the expression (set *global* 0)
        will assign the value zero to the print vector. Now since
        print vectors cannot actually have values, the evaluation
        of this expression must call upon the native assignment
        operation (other conventions can be imagined but this is <em>prima
        facie</em> the most logical). Let us suppose that assign!
        does the job of assignment in Blub. In this case, 'set'
        will be defined as </font></p>
        <p align="left"><font size="2" face="Verdana">(define set<br>
        Symbol Value -&gt; (if (function-identifier? Symbol) <br>
        </font><font color="#FFFFFF" size="2" face="Verdana">xxxxxxxxxxxxxxxxxxx</font><font
        size="2" face="Verdana">(error &quot;~A is a
        function.~%&quot; Symbol) <br>
        </font><font color="#FFFFFF" size="2" face="Verdana">xxxxxxxxxxxxxxxxxxx</font><font
        size="2" face="Verdana">(assign! (get-global-symbol
        Symbol) Value))</font></p>
        <p align="left"><font size="2" face="Verdana">Here the
        semantics of 'set' prevents the user from overwriting a
        function by a global assignment. The function
        'get-global-symbol' actually extracts the platform global
        variable which is updated. A similar strategy can be used
        for 'define'. </font></p>
        <p align="left"><font size="2" face="Verdana">The only
        disadvantage of this strategy is that it is slow in
        execution, since every global assignment must first pass
        a test and then be mapped before any assignment is made.
        Practically however, you can arrange for this to be
        avoided in your backend. In 99% of cases the identity of
        the global is known in advance and hence you can perform
        these tests and mappings at compile time and hence
        compile them out. Only in the rare cases where the
        assignment is made using dynamically generated variables,
        do you need to retain the code in the original form.</font></p>
        <p align="left"><font size="2" face="Verdana">If you are
        compiling into a language like Scheme, where you do not
        need to use print vectors for innocent symbols, the
        procedure is the same, except that 'get-global-symbol'
        will not be needed.</font></p>
        <p align="left"><a name="Tail Recursion Optimisation"></a><font
        size="3" face="Verdana"><strong>Tail Recursion
        Optimisation</strong></font></p>
        <p align="left"><font size="2" face="Verdana">K</font><font
        size="2" face="Symbol">l </font><font size="2"
        face="Verdana">and Shen both expect tail recursion
        optimisation and this is heavily used in the Shen source.
        Certain platforms like Python do not support this
        feature. Hence you may find that your code will not run
        under such a platform.</font></p>
        <p align="left"><font size="2" face="Verdana">In these
        cases, the platform generally expects the programmer to
        write in a iterative style and provides some mechanism
        for doing that; either FOR, WHILE, DO, LOOP etc. You have
        to learn how to map tail recursive functions into this
        idiom to make the port work. There are no more words of
        advice here.</font></p>
        <p align="left"><a
        name="Currying and Partial Applications"></a><font
        size="3" face="Verdana"><strong>Currying and Partial
        Applications</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Qi II, K</font><font
        size="2" face="Symbol">l </font><font size="2"
        face="Verdana">and Shen all respect the lambda calculus
        and therefore support and expect currying and partial
        applications. Some languages, like Common Lisp, do not
        support currying. Generally, even with such platforms,
        currying is no problem if you can statically recognise
        that the application is a partial one. For example,
        knowing that 'append' is a 2-place function enables your
        backend to generate the appropriate closure. </font></p>
        <p align="left"><font size="2" face="Verdana">However if
        the function is higher-order, then the problem is more
        difficult since the partial application may be made at
        run time. The case you have to consider is one where
        there is an application of an input to another part of
        the input.</font></p>
        <p align="left"><font size="2" face="Verdana">(define
        reduce<br>
        _ [] Base -&gt; Base<br>
        C [X] Base -&gt; (C X Base)<br>
        C [X Y | Z] Base -&gt; (reduce C [(C X Y) | Z] Base)) </font></p>
        <p align="left"><font size="2" face="Verdana">Here
        (reduce + L 0) totals a list L of numbers.</font></p>
        <p align="left"><font size="2" face="Verdana">Here we
        discuss three approaches to writing your backend to cope
        with currying in higher-order functions - <strong>dynamic
        currying</strong>, <strong>static currying</strong> and <strong>currying</strong>
        <strong>on demand</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">Qi I and II
        were written in Lisp and used <u>dynamic currying</u>.
        This meant that if an application was made by a
        higher-order function during run time, Qi II would pause
        to see if a partial application was made and if necessary
        it would dynamically generate a closure based on
        calculating the arity of the partially applied function.
        This was rather slow even with hash table lookup. </font></p>
        <p align="left"><font size="2" face="Verdana">An
        alternative is <u>static currying</u>. In static
        currying, all functions are curried at compile time and
        hence, apart from a few functions declared as special
        (i.e. not to be curried), all functions are 1-place
        functions. This solves the overload of dynamic currying
        but raises significant problems of its own. </font></p>
        <p align="left"><font size="2" face="Verdana">In CLisp,
        tail recursive functions of an arity &gt; 1, do not
        compile with tail recursion optimisation when static
        currying is applied. Therefore programs may crash which
        rely on TRO in the compilation of these functions. The
        significance can be seen in the n queens program in the
        Test Programs folder which crashed under static currying
        with (n-queens 6) (platform CLisp) but which ran fine
        under dynamic currying. </font></p>
        <p align="left"><font size="2" face="Verdana">An
        alternative to both approaches is <strong>currying on
        demand</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">Currying on
        demand is used for higher-order functions in the CL port
        of Shen. The function argument is applied in an uncurried
        form and 99% of the time this is the correct application.
        If the function is intended to be used in a partial
        application, then an error will be raised. This error
        should be trapped and in that case dynamic currying is
        used. For those who understand Lisp, here is the Shen map
        (MAPCAR) function.</font></p>
        <p align="left"><font size="2" face="Verdana">(DEFUN map
        (V1593 V1594)<br>
        </font><font color="#FFFFFF" size="2" face="Verdana">...</font><font
        size="2" face="Verdana">(COND ((NULL V1594) NIL)<br>
        </font><font color="#FFFFFF" size="2" face="Verdana">.............</font><font
        size="2" face="Verdana">((CONSP V1594) <br>
        </font><font color="#FFFFFF" size="2" face="Verdana">..............</font><font
        size="2" face="Verdana">(CONS (trap-error </font><font
        color="#008000" size="2" face="Verdana">(FUNCALL V1593
        (CAR V1594))</font><font size="2" face="Verdana"><br>
        </font><font color="#FFFFFF" size="2" face="Verdana">.......................................</font><font
        color="#FF0000" size="2" face="Verdana">(lambda E
        (FUNCALL (nest-lambda V1593) <br>
        </font><font color="#FFFFFF" size="2" face="Verdana">.................................................................................</font><font
        color="#FF0000" size="2" face="Verdana">(CAR V1594))))</font><font
        size="2" face="Verdana"> <br>
        </font><font color="#FFFFFF" size="2" face="Verdana">........................</font><font
        size="2" face="Verdana">(map V1593 (CDR V1594))))<br>
        </font><font color="#FFFFFF" size="2" face="Verdana">,,,,,,,,,,,,,</font><font
        size="2" face="Verdana">(T (shen_sysf_error 'map))))</font></p>
        <p align="left"><font size="2" face="Verdana">Here the
        uncurried call is made (green) and if an error is raised,
        then it is trapped and the nest-lambda function
        constructs a closure based on the arity of the function
        (red) and repeats the application. Extra security can be
        gained by examining the error (E) using <strong>error-to-string
        </strong>and verifying it is an arity error before
        currying. </font></p>
        <p align="left"><font size="2" face="Verdana">We strongly
        recommend this approach over static or dynamic currying
        in platforms that do not provide partial application
        (like CL). The following table compares the three
        methods.</font></p>
        <div align="center"><center><table border="1"
        cellpadding="6">
            <tr>
                <td><p align="center"><font size="2"
                face="Verdana"><strong>Static Currying</strong></font></p>
                </td>
                <td><p align="center"><font size="2"
                face="Verdana"><strong>Dynamic Currying</strong></font></p>
                </td>
                <td><p align="center"><font size="2"
                face="Verdana"><strong>Currying on Demand </strong></font></p>
                </td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">Higher-order
                functions run quickly</font></td>
                <td><font size="2" face="Verdana">Higher-order
                functions run slowly</font></td>
                <td><font size="2" face="Verdana">Higher-order
                functions run quickly</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">Never requires
                arity lookup</font></td>
                <td><font size="2" face="Verdana">Always requires
                arity lookup</font></td>
                <td><font size="2" face="Verdana">Hardly ever
                requires arity lookup</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">Makes TRO fail
                in some platforms</font></td>
                <td><font size="2" face="Verdana">TRO never fails
                because of this method</font></td>
                <td><font size="2" face="Verdana">TRO never fails
                because of this method</font></td>
            </tr>
        </table>
        </center></div><p align="left"><a
        name="Optimising your Port"></a><font size="3"
        face="Verdana"><strong>Optimising your Port</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        performance of Shen is as much dependent on the nature of
        the port as it is on the platform it is ported to. The
        difference between a naive port and an optimised one can
        amount to two orders of magnitude. In general,
        understanding how to get the fastest port will revolve on
        understanding the bottlenecks and optimisations inherent
        in your chosen platform. What follows here is therefore,
        by necessity, quite general.</font></p>
        <p align="left"><font size="2" face="Verdana">Basically
        there are two forms of optimisation; <strong>peephole
        optimisation</strong> and <strong>backend optimisation</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>Peephole
        optimisation </strong>occurs when the native platform
        offers an inbuilt system function which is faster than
        the canned version that comes with Shen. The
        implementation of Shen follows a 'batteries included'
        model wherein nothing is assumed of the platform once the
        primitives in K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> are defined. Hence the source
        code includes definitions of standard functions which may
        be less efficient than easily accessible platform
        specific versions.</font></p>
        <p align="left"><font size="2" face="Verdana">The Shen
        license allows the platform developer to replace these
        definitions provided the <em>spec of the function is not
        changed</em> i.e. the performance is improved but the
        behaviour still remains conformant to the standard. In
        that case it is feasible to use the system version and
        the Shen definition should be replaced by the new version
        but <u>the old name should be retained</u> i.e. the body
        of the definition of the Shen version should be changed
        to point to the system version. In this way the resulting
        port conforms to the Shen standard. This sort of code
        should be put into a file overwrite.blub in your port
        folder.</font></p>
        <p align="left"><font size="2" face="Verdana">Peephole
        optimisation can be very significant for oft-used low
        level functions. See for instance the file <strong>overwrite.lsp
        </strong>in the CL directory which replaces slow Shen
        generic functions by fast CL ones. </font></p>
        <p align="left"><font size="2" face="Verdana"><strong>Backend
        optimisation </strong>occurs through the backend which
        compiles K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> to native code. For instance, K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> contains no provision for distinguishing
        EQUAL and EQ. This is deliberate. In my opinion, such
        optimisations are the province of the compiler and the
        Common Lisp Qi actually performed these optimisations
        automatically on compiling into Common Lisp. Backend
        optimisation is deeply dependent on the platform. A
        special case of this is<strong> pattern factorisation</strong>.
        Pattern factorisation removes repeated tests in K</font><font
        size="2" face="Symbol">l </font><font size="2"
        face="Verdana">code generated from overlapping patterns
        in a Shen function definition (see </font><a
        href="http://www.lambdassociates.org/Book/page235.htm"><font
        size="2" face="Verdana">www.lambdassociates.org/Book/page235.htm</font></a><font
        size="2" face="Verdana"> for an explanation). Performing
        this efficiently requires a JUMP or GOTO to be supported
        by the platform. For an example of factorised code, see
        the </font><a
        href="http://www.lambdassociates.org/studies/study10.htm"><font
        size="2" face="Verdana">tenth code study</font></a><font
        size="2" face="Verdana"> on Lambda Associates. At current
        time (July 2011) this is yet not used in the Lisp port of
        Shen.</font></p>
        </td>
    </tr>
</table>
</center></div>

<p><font color="#0000A0" size="6" face="Edwardian Script ITC">Mark</font></p>

<p><font size="2" face="Verdana">copyright (c) 2011, Dr Mark
Tarver</font></p>
</body>
</html>
