<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Shen doc 18The Official Shen Standard</title>
</head>

<body>

<p>&nbsp;</p>
<div align="center"><center>

<table border="1" cellpadding="30" width="70%" bgcolor="#FFFFFF">
    <tr>
        <td><div align="right"><table border="0" width="100%">
            <tr>
                <td valign="top"><font size="7" face="Impact">Shen
                doc 19<br>
                </font><font size="6" face="Impact">The Official
                Shen Standard</font><table border="0"
                cellspacing="0">
                    <tr>
                        <td><em><img src="logo.gif" width="423"
                        height="442"></em></td>
                    </tr>
                    <tr>
                        <td><p align="right"><font size="2"><em>logo
                        by Malcolm Still</em></font></p>
                        </td>
                    </tr>
                </table>
                </td>
                <td width="100%"><blockquote>
                    <p><a href="#Acknowledgements"><font size="2"
                    face="Verdana">Acknowledgements</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Shen_and_Qi"><font size="2"
                    face="Verdana">Shen and Qi </font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Kl"><font size="2"
                    face="Verdana">K</font><font size="2"
                    face="Symbol">l</font><font size="2"
                    face="Verdana"> </font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#The Motivation for Shen"><font
                    size="2" face="Verdana">The Motivation for
                    Shen</font></a><font size="2" face="Verdana"><br>
                    </font><a href="#Future Development of Shen"><font
                    size="2" face="Verdana">Future Development of
                    Shen</font></a><font size="2" face="Verdana"><br>
                    </font><a href="#The Basic Types in Shen"><font
                    size="2" face="Verdana">Basic Types in Shen
                    and K</font><font size="2" face="Symbol">l</font></a><font
                    size="2" face="Symbol"><br>
                    </font><a
                    href="#The Primitive Functions of K Lambda"><font
                    size="2" face="Verdana">The Primitive
                    Functions of K</font><font size="2"
                    face="Symbol">l</font></a><font size="2"
                    face="Symbol"><br>
                    </font><a href="#The Syntax of Kl"><font
                    size="2" face="Verdana">The Syntax of K</font><font
                    size="2" face="Symbol">l</font></a><font
                    size="2" face="Symbol"><br>
                    </font><a
                    href="#Notes on the Implementation of Kl"><font
                    size="2" face="Verdana">Notes on the
                    Implementation of K</font><font size="2"
                    face="Symbol">l</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Kl and the Shen Evaluator"><font
                    size="2" face="Verdana">K</font><font
                    size="2" face="Symbol">l </font><font
                    size="2" face="Verdana">and the Shen
                    Evaluator</font></a><font size="3"
                    face="Verdana"><strong><br>
                    </strong></font><a href="#Boolean Operators"><font
                    size="2" face="Verdana">Boolean Operators</font></a><font
                    size="2" face="Symbol"><br>
                    </font><a href="#The Syntax of Symbols"><font
                    size="2" face="Verdana">The Syntax of Symbols</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a
                    href="#The Semantics of Symbols in Shen and KLambda"><font
                    size="2" face="Verdana">The Semantics of
                    Symbols in Shen and K</font></a><a
                    href="#Kl and the Shen Evaluator"><font
                    size="2" face="Symbol">l</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Packages"><font size="2"
                    face="Verdana">Packages</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Prolog"><font size="2"
                    face="Verdana">Prolog</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Shen-YACC II"><font size="2"
                    face="Verdana">Shen-YACC II</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Strings"><font size="2"
                    face="Verdana">Strings and Bytes</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a
                    href="#Strings and Pattern Matching"><font
                    size="2" face="Verdana">Strings and Pattern
                    Matching</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Lists"><font size="2"
                    face="Verdana">Lists</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Characters"><font size="2"
                    face="Verdana">Characters</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Streams"><font size="2"
                    face="Verdana">Streams</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Reader Macros"><font
                    size="2" face="Verdana">Reader Macros</font></a><font
                    size="3" face="Verdana"><strong><br>
                    </strong></font><a href="#Vectors"><font
                    size="2" face="Verdana">Vectors</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a
                    href="#Standard Vectors and Pattern Matching"><font
                    size="2" face="Verdana">Standard Vectors and
                    Pattern Matching</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Tuples"><font size="2"
                    face="Verdana">Non-standard Vectors and
                    Tuples</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Equality"><font size="2"
                    face="Verdana">Equality</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Priniting"><font size="2"
                    face="Verdana">I/O</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Generic Functions"><font
                    size="2" face="Verdana">Generic Functions</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Type declarations"><font
                    size="2" face="Verdana">Type Declarations</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#External Global Variables"><font
                    size="2" face="Verdana">External Global
                    Variables</font></a><font size="3"
                    face="Verdana"><strong><br>
                    </strong></font><a
                    href="#Property Lists and Hashing"><font
                    size="2" face="Verdana">Property Lists and
                    Hashing</font></a><font size="2"
                    face="Verdana"><br>
                    </font><a href="#Error Handling"><font
                    size="2" face="Verdana">Error Handling</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Numbers"><font size="2"
                    face="Verdana">Numbers</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Floats and Integers"><font
                    size="2" face="Verdana">Floats and Integers</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#The Timer"><font size="2"
                    face="Verdana">The Timer</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Comments"><font size="2"
                    face="Verdana">Comments</font></a><font
                    size="2" face="Verdana"><br>
                    </font><a href="#Special Forms"><font
                    size="2" face="Verdana">Special Forms</font></a><font
                    size="2" face="Verdana"><br>
                    </font></p>
                </blockquote>
                </td>
            </tr>
        </table>
        </div><p align="left"><a name="Acknowledgements"></a><font
        size="3" face="Verdana"><strong>Acknowledgements </strong></font></p>
        <p align="left"><font size="2" face="Verdana">This
        document benefited from discussions with Vasil Diadov,
        Kian Wilcox, Carl Shapiro, Willi Riha and Brian
        Spilsbury. </font></p>
        <p align="left"><a name="Shen_and_Qi"></a><font size="3"
        face="Verdana"><strong>Shen and Qi </strong></font></p>
        <p align="left"><font size="2" face="Verdana">Shen was
        directly derived from Qi. Qi is a hypermodern functional
        language that offers many features not currently
        available under other functional platforms. </font></p>
        <p align="left"><font size="2" face="Verdana">Qi was
        written solely to run under Common Lisp. The motive for
        Shen came from the observation that the implementation of
        Qi used only 15% of the system functions described in <em>Common
        Lisp: the Language</em>. </font></p>
        <p align="left"><font size="2" face="Verdana">The Shen
        mission was to develop an ultra-portable version of Qi
        that can run under a wide variety of platforms and which
        incorporates missing features in Qi such as streams. This
        approach involved rewriting and redesigning Qi to fit
        within the smallest feasible instruction set. </font></p>
        <p align="left"><a name="Kl"></a><font size="3"
        face="Verdana"><strong>K</strong></font><font size="3"
        face="Symbol"><strong>l</strong></font><font size="3"
        face="Verdana"><strong> </strong></font></p>
        <p align="left"><font size="2" face="Verdana">The means
        of achieving this involves developing a small fast Lisp
        called <strong>K</strong></font><font size="2"
        face="Symbol"><strong>l</strong></font><font size="2"
        face="Verdana"><strong> </strong>which is rich enough to
        encode Qi, but small enough to be easily mapped into
        other platforms or implemented as a standalone. </font></p>
        <p align="left"><font size="2" face="Verdana">In terms of
        design, K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> reflects the following design
        criteria.</font></p>
        <p align="left"><font size="2" face="Verdana">1. It
        should be powerful enough to express Qi.<br>
        2. It should be minimal, with very few primitives and so
        easy to implement. No macros, optional arguments etc.
        because Shen can support all these things already.<br>
        3. It is not designed as a language to compete against
        Common Lisp; deliberately. It is a Lisp assembly language
        for a higher level language. The minimalism is
        deliberate.<br>
        4. It should be clean; i.e. it should support partial
        applications, lexical scoping and tail recursion
        optimisation.<br>
        5. It should be fast; it should support type
        declarations.</font></p>
        <p align="left"><font size="2" face="Verdana">Some
        comparable small Lisps to K</font><font size="2"
        face="Symbol">l </font><font size="2" face="Verdana">are </font><a
        href="http://software-lab.de/radical.pdf"><font size="2"
        face="Verdana">PicoLisp</font></a><font size="2"
        face="Verdana">, </font><a
        href="http://code.google.com/p/femtolisp/"><font size="2"
        face="Verdana">FemtoLisp</font></a><font size="2"
        face="Verdana">, </font><a
        href="http://tinyscheme.sourceforge.net/"><font size="2"
        face="Verdana">TinyScheme</font></a><font size="2"
        face="Verdana"> and </font><a
        href="http://www.uv.es/tung/smlisp/smlisp-ref.pdf"><font
        size="2" face="Verdana">SmallLisp</font></a><font
        size="2" face="Verdana">. </font></p>
        <p align="left"><font size="2" face="Verdana">Unlike
        Common Lisp, K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> is very portable over different
        platforms. In place of Common Lisp's 1150 pages of
        specification, K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> requires only 46 system
        functions. It is much easier to develop a stand-alone
        implementation of K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> than to build a complete version
        of CL. Even more significantly, it is possible to map K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> into popular existing platforms such as
        Clojure, Python as well as Common Lisp. </font></p>
        <p align="left"><font size="2" face="Verdana">The
        implementation, Shen, attached to this document runs Qi
        on this reduced instruction set and, in terms of
        primitives required, has nearly 1/3 of the footprint of
        Qi II. <u>Shen is entirely defined in K</u></font><font
        size="2" face="Symbol"><u>l</u></font><font size="2"
        face="Verdana">. Hence Shen is no more difficult to port
        than K</font><font size="2" face="Symbol">l </font><font
        size="2" face="Verdana">itself. All that needs to be done
        is to map the simple reduced instruction set of K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> into the chosen platform. Our
        distribution in fact contains one such mapping - of K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> to Common Lisp; and this is done in 250
        lines of code.</font></p>
        <p align="left"><font size="2" face="Verdana">K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> misses many of the features of bigger
        Lisps (like macros) because Shen effectively incorporates
        many of these features. Even LIST and QUOTE are missing
        from K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> because they are not needed for
        Shen and Qi has never needed or missed them. Similarly we
        do not impose a comment convention on K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> because we do not consider that people
        need to or should write in K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">. The
        emphasis is on devising an absolutely efficient minimal
        set needed to port Qi which is easy for people to code in
        other languages.</font></p>
        <p align="left"><font size="2" face="Verdana">However
        anybody who implements K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">, and
        wants to write directly in this notation, can add extra
        features to their implementation to K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana">. This does not affect the standard; just
        as a CL which includes (e.g.) threads does not cease to
        be a CL even though it incorporates a non-standard
        feature. <u>However the systems code for Shen will not
        rely on extra features outside the standard</u>. It is
        intentionally minimal.</font></p>
        <p align="left"><a name="The Motivation for Shen"></a><font
        face="Verdana"><strong>The Motivation for </strong></font><font
        size="3" face="Verdana"><strong>Shen </strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        development of Shen was motivated by the desire to use Qi
        outside the ambit of Common Lisp. Though Common Lisp is a
        very powerful language, it's usage and libraries do not
        compare well with other languages such as Python. It is,
        for example, difficult to find providers who support
        Common Lisp, though many providers will offer Python as
        part of their services. Hence Shen was devised as the
        solution. Shen is Qi packaged to run under many
        platforms.</font></p>
        <p><font size="2" face="Verdana">People have asked why
        Shen is called 'Shen' . There is a deep reason. </font></p>
        <p><font size="2" face="Verdana">The words 'qi' and
        'shen' are part of the Taoist vocabulary. The concept of <em>shen</em>
        belongs to a triad; <em>jing</em>, <em>qi</em>, <em>shen</em>.
        They represent stages in the refinement of energy. <em>Jing</em>
        is the sexual essence; it is the most hormonal and least
        refined of the life energies but important in the
        alchemical transformation of our energy into spirit. <em>Qi</em>
        is better known as life-force or vitality, which
        accumulates when <em>jing</em> is conserved and our
        kidney and natal energy is nourished. <em>Shen</em> is
        the spiritual energy that shows in shining eyes and an
        alert mind. In Taoist alchemy, the transmutation of <em>jing</em>
        into <em>qi</em>, and <em>qi</em> into <em>shen</em> is
        the nature of the highest Taoist practice which leads to
        seperation of the <em>shen</em> from the corporeal form,
        immortality and liberation from the wheel of life and
        death. For this reason <em>shen</em> is translated as
        'spirit'</font></p>
        <p><font size="2" face="Verdana">In terms of this
        process, <em>Qi</em> was nourished within the physical
        body of a specific platform which was Common Lisp. Having
        nurtured it to become strong, the goal must be now to
        seperate <em>Qi</em> from conceptual dependence on Common
        Lisp to be able to exist as a spirit that can run on any
        LISP. Hence the process of our work mirrors the ancient
        Taoist alchemists.</font></p>
        <p><a name="Future Development of Shen"></a><font
        size="3" face="Verdana"><strong>Future Development of
        Shen</strong></font></p>
        <p><font size="2" face="Verdana">Shen is that of a RISC
        version of Qi II with extensions to incorporate streams;
        it is Qi running on a reduced instruction set and that
        reduced instruction set defines (much of) K</font><font
        size="2" face="Symbol">l. </font><font size="2"
        face="Verdana"><u>However this release and the
        accompanying language definition are by no means the
        final word.</u> We are actively developing standards for
        other aspects of a modern programming language beyond
        what exists here. </font></p>
        <p><font size="2" face="Verdana">The release of Shen
        follows this convention: all spec changes increment the
        leading digit; all patches increment the number following
        the point. </font></p>
        <p align="left"><a name="The Basic Types in Shen"></a><font
        size="3" face="Verdana"><strong>The Basic Types in Shen
        and K</strong></font><font size="3" face="Symbol"><strong>l</strong></font></p>
        <p align="left"><font size="2" face="Verdana">There are
        12 basic types in Shen.</font></p>
        <p align="left"><font size="2" face="Verdana">1. symbols
        .... abc hi-there, The_browncow_jumped_over_the_moon<br>
        2. strings ..... any characters enclosed in &quot;s<br>
        3. numbers .... all objects closed under +, /, -, * <br>
        4. booleans ... true, false<br>
        5. streams<br>
        6. exceptions <br>
        7. vectors<br>
        8. functions<br>
        9. lists<br>
        10. tuples<br>
        11. closures<br>
        12. continuations</font></p>
        <p align="left"><font size="2" face="Verdana">Note that
        the last two categories can merge depending on the
        platform.</font></p>
        <p align="left"><font size="2" face="Verdana">Any symbol,
        string, number or boolean is an <strong>atom</strong>.
        Booleans are <strong>true</strong> and <strong>false</strong>.
        Atoms are self-evaluating. As in Qi, booleans are not
        counted as symbols (in Shen they have their own type).
        All symbols apart from those used to apply functions are
        treated as implicitly quoted.</font></p>
        <p align="left"><font size="2" face="Verdana">The type
        system of Shen differs from Qi II in not placing
        variables and symbols into different types. This arises
        mainly from dropping rule closures that appeared in Qi
        II. The type <strong>stream</strong> is now inbuilt since
        several primitives use this concept.</font></p>
        <p align="left"><a
        name="The Primitive Functions of K Lambda"></a><font
        size="3" face="Verdana"><strong>The Primitive Functions
        of K</strong></font><font size="3" face="Symbol"><strong>l</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        following set represents the set of 46 primitive
        functions which Shen requires and which are used in K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana">. All other functions are included in the
        Shen sources. The CL definitions are given to explain the
        semantics of these functions. Note in some cases these
        primitives can be reduced still further (e.g <strong>and</strong>
        in terms of <strong>if </strong>etc). In fact lambda
        alone is sufficient, but impractical. The instruction set
        is therefore a balance between economy of primitives
        (easy to implement but inefficient in execution) and
        practicality (more difficult to implement but possibly
        faster).</font></p>
        <p align="left"><font size="2" face="Verdana">K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> uses strict applicative order evaluation
        except for the boolean operations etc. which follow the
        usual pattern. NIL is just a symbol with no special
        status. () denotes the empty list.</font></p>
        <div align="center"><center><table border="1">
            <tr>
                <td><p align="center"><font size="2"
                face="Verdana"><strong>Category</strong></font></p>
                </td>
                <td align="center" valign="top"><font size="2"
                face="Verdana"><strong>Function </strong></font></td>
                <td width="30%"><p align="center"><font size="2"
                face="Verdana"><strong>Type</strong></font></p>
                </td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Boolean Operations (4)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">if</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">boolean test</font></td>
                <td width="30%"><font size="2" face="Verdana">boolean
                --&gt; A --&gt; A --&gt; A</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">and</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">boolean and</font></td>
                <td width="30%"><font size="2" face="Verdana">boolean
                --&gt; boolean --&gt; boolean</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">or </font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">boolean or</font></td>
                <td width="30%"><font size="2" face="Verdana">boolean
                --&gt; boolean --&gt; boolean</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">cond</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">case form</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Symbols (</strong></font><font
                color="#000000" size="2" face="Verdana"><strong>1</strong></font><font
                size="2" face="Verdana"><strong>)</strong></font></td>
                <td align="center" valign="top" bgcolor="#C0C0C0">&nbsp;</td>
                <td width="30%" bgcolor="#C0C0C0">&nbsp;</td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">intern</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">maps a string containing a symbol
                to a symbol</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Strings (7)</strong></font></td>
                <td align="center" valign="top" bgcolor="#C0C0C0">&nbsp;</td>
                <td width="30%" bgcolor="#C0C0C0">&nbsp;</td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">pos</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">given a natural number 0 ...n and
                a string S returns the nth unit string in S</font></td>
                <td width="30%"><font size="2" face="Verdana">string
                --&gt; number --&gt; string</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">tlstr</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">returns all but the first unit
                string of a string</font></td>
                <td width="30%"><font size="2" face="Verdana">string
                --&gt; string</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">cn</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">concatenates two strings</font></td>
                <td width="30%"><font size="2" face="Verdana">string
                --&gt; string --&gt; string</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">str</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">maps any atom to a string</font></td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; string</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">string?</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">test for strings</font></td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; boolean</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">n-&gt;string</font></td>
                <td align="center"><font size="2" face="Verdana">maps
                a code point in decimal to the corresponding unit
                string</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; string</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">string-&gt;n </font></td>
                <td align="center"><font size="2" face="Verdana">maps
                a unit string to the corresponding decimal</font></td>
                <td width="30%"><font size="2" face="Verdana">string
                --&gt; number</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Assignments (2)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">set</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">assigns a value to a symbol</font></td>
                <td width="30%"><font size="2" face="Verdana">(value
                X) : A; <br>
                X : symbol; <br>
                <u>Y : A;</u>______<br>
                (set X Y) : A;</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">value</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">retrieves the value of a symbol</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Error Handling (3)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">simple-error</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">prints an exception</font></td>
                <td width="30%"><font size="2" face="Verdana">string
                --&gt; A</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">trap-error</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">evaluates its first argument A; if
                it is not an exception returns the normal form,
                returns A else applies its second argument to the
                exception</font></td>
                <td width="30%"><font color="#000000" size="2"
                face="Verdana">A --&gt; (exception --&gt; A)
                --&gt; A </font></td>
            </tr>
            <tr>
                <td><font color="#000000" size="2" face="Verdana">error-to-string</font></td>
                <td align="center" valign="top"><font
                color="#000000" size="2" face="Verdana">maps an
                exception to a string</font></td>
                <td width="30%"><font color="#000000" size="2"
                face="Verdana">exception --&gt; string</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Lists (4)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">cons</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">add an element to the front of a
                list</font></td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; (list A) --&gt; (list A)</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">hd</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">take the head of a list</font></td>
                <td width="30%"><font size="2" face="Verdana">_</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">tl</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">return the tail of a list</font></td>
                <td width="30%"><font size="2" face="Verdana">(list
                A) --&gt; (list A)</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">cons?</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">test for non-empty list</font></td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; boolean</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Generic Functions (7)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">defun</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">basic Lisp function definer</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">lambda</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">lambda function</font></td>
                <td width="30%"><font size="2" face="Verdana"><u>X
                : A &gt;&gt; Y : B;</u><br>
                (lambda X Y) : (A --&gt; B);</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">let</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">local assignment</font></td>
                <td width="30%"><font size="2" face="Verdana">Y :
                B;<br>
                <u>X : B &gt;&gt; Z : A;</u><br>
                (let X Y Z ) : A</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">=</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">equality</font></td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; A --&gt; boolean</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">eval-kl</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">evaluation function</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">freeze</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">creates a continuation</font></td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; (lazy A)</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">type</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">labels the type of an expression</font></td>
                <td width="30%"><font size="2" face="Verdana"><u>X
                : A;</u><br>
                (type X A) : A;</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Vectors (4)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">absvector</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">create a vector in the native
                platform</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">address-&gt;</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">destructively assign a value to a
                vector address</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">&lt;-address</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">retrieve a value from a vector
                address</font></td>
                <td width="30%">&nbsp;</td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">absvector?</font></td>
                <td align="center" valign="top">&nbsp;</td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; boolean</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Streams and I/O (6)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">write-byte</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">write an unsigned 8 bit byte to a
                stream</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; (stream out) --&gt; number</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">read-byte</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">read an unsigned 8 bit byte from a
                stream</font></td>
                <td width="30%"><font size="2" face="Verdana">(stream
                in) --&gt; number</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">open</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">open a stream</font></td>
                <td width="30%"><font size="2" face="Verdana"><u>Path
                : string;</u><br>
                (open P D) : (stream D);</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">close</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">close a stream</font></td>
                <td width="30%"><font size="2" face="Verdana">(stream
                A) --&gt; (list B)</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Time (1)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">get-time</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">get the run/real time</font></td>
                <td width="30%"><font size="2" face="Verdana">symbol
                --&gt; number</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font size="2"
                face="Verdana"><strong>Arithmetic (9)</strong></font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">+</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">addition</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; number</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">-</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">subtraction</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; number</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">*</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">multiplication</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; number</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">/</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">division</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; number</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">&gt;</font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">greater than</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; boolean</font></td>
            </tr>
            <tr>
                <td>&lt;</td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">less than</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; boolean</font></td>
            </tr>
            <tr>
                <td>&gt;=</td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">greater than or equal to </font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; boolean</font></td>
            </tr>
            <tr>
                <td>&lt;=</td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">less than or equal to</font></td>
                <td width="30%"><font size="2" face="Verdana">number
                --&gt; number --&gt; boolean</font></td>
            </tr>
            <tr>
                <td><font size="2" face="Verdana">number? </font></td>
                <td align="center" valign="top"><font size="2"
                face="Verdana">number test</font></td>
                <td width="30%"><font size="2" face="Verdana">A
                --&gt; boolean</font></td>
            </tr>
            <tr>
                <td colspan="3" bgcolor="#C0C0C0"><font
                face="Verdana"><strong>Total 46</strong></font><font
                color="#FF0000" face="Verdana"><strong> </strong></font><font
                face="Verdana"><strong>functions</strong></font></td>
            </tr>
        </table>
        </center></div><p align="left"><a name="The Syntax of Kl"></a><font
        size="3" face="Verdana"><strong>The Syntax of K</strong></font><font
        size="3" face="Symbol"><strong>l</strong></font></p>
        <p align="left"><font size="2" face="Verdana">is very
        simple and conforms to a Lisp. Well-formed sentences of K</font><font
        size="2" face="Symbol">l </font><font size="2"
        face="Verdana">are symbolic expressions (s-exprs).</font></p>
        <ol>
            <li><p align="left"><font size="2" face="Verdana">Any
                symbol, boolean, string or number is an atom.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">Any
                atom is an s-expr as is ().</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">Any
                abstraction (lambda X Y) is an s-expr if X is a
                symbol and Y is an s-expr.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">Any
                local assignment (let X Y Z) is an s-expr if X is
                a symbol and Y and Z are s-exprs.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">Any
                definition (defun F X Y) is an s-expr if F is a
                symbol and X is a (possibly empty) list of
                symbols (formal parameters) and Y is an s-expr.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">Any
                application (X<sub>1</sub> ... X<sub>n</sub>) is
                an s-expr if X<sub>1</sub>, ... X<sub>n</sub> are
                s-exprs.</font></p>
            </li>
        </ol>
        <p align="left"><a
        name="Notes on the Implementation of Kl"></a><font
        size="3" face="Verdana"><strong>Notes on the
        Implementation of K</strong></font><font size="3"
        face="Symbol"><strong>l</strong></font></p>
        <p align="left"><font size="2" face="Verdana">These notes
        are for programmers wishing to implement K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana">.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong><u>Tail
        recursion optimisation is a must and part of the K</u></strong></font><font
        size="2" face="Symbol"><strong><u>l</u></strong></font><font
        size="2" face="Verdana"><strong><u> standard</u></strong>.
        Quite of few of the reader routines for Shen will not
        work in a language like Python which lacks it. In such a
        case, a platform provider working to move Shen to a
        non-TCO language has to consider how to port tail
        recursive K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> code.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong><u>K</u></strong></font><font
        size="2" face="Symbol"><strong><u>l</u></strong></font><font
        size="2" face="Verdana"><strong><u> uses lexical scoping</u></strong>.
        This is pretty standard now. Qi II actually used dynamic
        scoping in its implementation of Prolog to implement
        variable binding but in Shen this is now done with
        vectors.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong><u>K</u></strong></font><font
        size="2" face="Symbol"><strong><u>l</u></strong></font><font
        size="2" face="Verdana"><strong><u> follows applicative
        order evaluation</u></strong>. Except for the following
        constructions.</font></p>
        <p align="center"><font size="2" face="Verdana"><strong>cond,
        and, or, if, freeze, let, defun</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong><u>K</u></strong></font><font
        size="2" face="Symbol"><strong><u>l</u></strong></font><font
        size="2" face="Verdana"><strong><u> follows a dual
        namespace model</u></strong>. A classic model for a Lisp
        views 'defun' and 'set' as interchangable. &nbsp;Both are
        thought of as asserting a math'l identity so that <strong>&nbsp;(defun
        f (x y) y)</strong> is sugar for <strong>(set 'f (lambda
        x (lambda y y)))</strong>. &nbsp;This model supposes a
        single namespace for functions and variables. &nbsp;You
        have this in Python.<br>
        <br>
        So in the classic model 'defun' and 'set' together are
        logically superfluos. It is more reasonable to regard
        'set' as logically prior since incrementing a global
        variable is much more easily carried out through 'set'
        than 'defun'. Incrementing should be very fast - function
        compilation is generally very slow.<br>
        <br>
        In a dual namespace model, the 'defun' and 'set' are
        regarded as creating an association between the symbol
        and something else; <u>it is a mapping not an assertion
        of identity</u>. </font></p>
        <p><font size="2" face="Verdana">Generally Qi and Shen
        require a dual namespace for symbols. &nbsp;The reason
        for this is to do with the Qi evaluation strategy for
        symbols which is that symbols are self-evaluating.
        &nbsp;In Qi the symbol 'f' evaluates to itself. &nbsp;If
        we want to get at the value associated with 'f', we type
        '(value f)'. &nbsp;<u>Hence f is not thought of as
        shorthand for a value, but is merely a symbol to which
        objects (definitions, global assignments etc) can be
        attached.</u><br>
        <br>
        Generally, if we had a single namespace, we would have a
        convention of a different kind. For instance if '(set f
        6)' entailed that 'f' <em>really meant</em> (was just a
        shorthand for) 6, then we would expect that typing in 'f'
        to the REPL would return 6. &nbsp;In Python that's
        exactly what happens with symbols.</font></p>
        <div align="center"><center><table border="2"
        cellpadding="10" width="50%" bgcolor="#000000">
            <tr>
                <td><font color="#FFFFFF"><strong>&gt;&gt;&gt; f
                = 9<br>
                &gt;&gt;&gt; f<br>
                9<br>
                &gt;&gt;&gt; def f (): return(9)<br>
                ...<br>
                &gt;&gt;&gt; f<br>
                &lt;function f at 0x024574F0&gt;</strong></font></td>
            </tr>
        </table>
        </center></div><p><font size="2" face="Verdana">But Qi
        does not work that way. &nbsp;Allowing symbols as
        self-evaluating really points away from this model.
        &nbsp;Hence K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> and Shen are committed to the
        dual namespace approach. &nbsp;</font></p>
        <p><font size="2" face="Verdana"><strong><u>Partial
        applications are mandatory</u></strong>. Thus (defun f (x
        y) ....) and (defun f (x) (lambda y ...)) are equivalent.
        There are efficient techniques for compiling K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> into languages which don't respect this
        rule (like CL) - see the document on porting.</font></p>
        <p align="left"><font size="2" face="Verdana">Note in
        Shen 8.0, typed zero place functions were introduced.
        Here is <strong>pi</strong> as a constant.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        pi<br>
        {--&gt; number}<br>
        -&gt; 3.142)</strong></font></p>
        <p align="left"><font size="2" face="Verdana">In K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> </font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defun
        pi () 3.142)</strong></font></p>
        <p><a name="Kl and the Shen Evaluator"></a><font size="3"
        face="Verdana"><strong>K</strong></font><font size="3"
        face="Symbol"><strong>l </strong></font><font size="3"
        face="Verdana"><strong>and the Shen Evaluator</strong></font></p>
        <p><font size="2" face="Verdana">The Shen evaluator
        compiles Shen into K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> and K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana"> into
        native code. The Shen evaluator accepts S-exprs as legal
        input and since K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> expressions are such, <u>any K</u></font><font
        size="2" face="Symbol"><u>l</u></font><font size="2"
        face="Verdana"><u> expression is a legal input to Shen</u>.
        Note that if a K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> expression is typed into Shen,
        that special constructions such as the
        list/string/vectors constructors in Shen which are
        outside the K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> spec (see the sections below) <em>will
        actually work</em> within such expressions because they
        are compiled into legal K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">.
        Thus the function;</font></p>
        <p><font size="2" face="Verdana">A. (defun list-all (x y
        z) [x y z])</font></p>
        <p><font size="2" face="Verdana">is not legal K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> and would have to be written as follows
        to be legal K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> </font></p>
        <p><font size="2" face="Verdana">B. (defun list-all (x y
        z) (cons x (cons y (cons z ()))))</font></p>
        <p><font size="2" face="Verdana">However expression A.
        will be accepted and compiled by Shen into expression B. <u>Hence
        hybrid programming will work in Shen.</u> We don't
        actually recommend this style, because K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> is not designed for the purposes of
        programming, but for easy porting and implementation.
        However you can write K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana"> code
        in Shen which is as compact as Common Lisp.</font></p>
        <p align="left"><a name="Boolean Operators"></a><font
        size="3" face="Verdana"><strong>Boolean Operators</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The list of
        boolean operators contains some logical redundancy.
        Logically only <strong>if</strong> is required to define
        the rest. However even ANSI C contains a version of the
        basic repertoire <strong>if</strong>, <strong>and</strong>,
        <strong>or</strong>, <strong>not</strong> and the <strong>cond</strong>
        is trivially compilable into a nested <strong>if</strong>.
        Because K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> does not contain macros and uses
        strict applicative order evaluation outside boolean
        operations, these are not efficiently interdefinable in
        the language itself. Note that in K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana"> a <strong>cond</strong>
        that fails in all its cases does not deliver NIL (as in
        CL) but an error.</font></p>
        <p align="left"><font size="2" face="Verdana">Shen
        includes a <strong>cases</strong> statement which has the
        syntax</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(cases
        &lt;test a&gt; &lt;result a&gt;<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xxxxxx</strong></font><font
        size="2" face="Verdana"><strong>&lt;test b&gt; &lt;result
        b&gt;<br>
        ...............)</strong></font></p>
        <p align="left"><font size="2" face="Verdana">and which
        is equivalent to <strong>(if &lt;test a&gt; &lt;result
        a&gt; (if &lt;test b&gt; &lt;result b&gt; ....))</strong>.
        If no cases apply an error is returned.</font></p>
        <p align="left"><a name="The Syntax of Symbols"></a><font
        size="3" face="Verdana"><strong>The Syntax of Symbols</strong></font></p>
        <p align="left"><font size="2" face="Verdana">In Shen an
        atom is either a symbol, boolean, string or number. All
        atoms, thus including symbols, are self-evaluating. The
        empty list is not counted as an atom but is also
        self-evaluating. Hence there is no quote in K</font><font
        size="2" face="Symbol">l </font><font size="2"
        face="Verdana">or Shen. Mapping into CL which does use
        quote is trivial. The function <strong>symbol? </strong>is
        the recognisor for symbols; their BNF is as follows.</font></p>
        <p align="left"><font size="2" face="Verdana">&lt;symbol&gt;
        := &lt;alpha&gt; &lt;symbolchars&gt; | &lt;alpha&gt;<br>
        &lt;symbolchars&gt; := &lt;alpha&gt; &lt;symbolchars&gt;
        | &lt;digit&gt; &lt;symbolchars&gt; | &lt;alpha&gt; |
        &lt;digit&gt;</font></p>
        <p align="left"><font size="2" face="Verdana">&lt;alpha&gt;
        := a | b | c | d | e | f | g | h | i | j | k | l | m | n
        | o | p | q | r | s | t | u | v | w | x | y | z <br>
        &lt;alpha&gt; := A | B | C | D | E | F | G | H | I | J |
        K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y
        | Z<br>
        &lt;alpha&gt; := = | - | * | / | + | _ | ? | $ | ! | @ |
        ~ | . | &gt; | &lt; | &amp; | % | ' | #| ` | ; | : | { |
        }</font></p>
        <p align="left"><font size="2" face="Verdana">&lt;digit&gt;
        := 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</font></p>
        <p align="left"><font size="2" face="Verdana">A symbol is
        a variable if it begins in an uppercase letter.</font></p>
        <p align="left"><a
        name="The Semantics of Symbols in Shen and KLambda"></a><font
        size="3" face="Verdana"><strong>The Semantics of Symbols
        in Shen and K</strong></font><font size="3" face="Symbol"><strong>l</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Qi II and
        Common Lisp are all members of the Lisp family of
        languages. In Lisp, symbols are often semantically
        context sensitive; that is, the interpretation of a
        symbol may depend on the context in which it occurs. For
        example in this Common Lisp expression; (list 'John 'put
        'the 'car 'into 'reverse), or in Qi II [John put the car
        into reverse], the symbol 'reverse' denotes a symbol. But
        in Common Lisp the expressions <strong>(reverse '(1 2 3))</strong>
        (in Qi II <strong>(reverse [1 2 3])</strong>) and <strong>(mapcar
        'reverse '((1 2) (2 3) (3 4)))</strong>, (in Qi II <strong>(map
        reverse [[1 2] [2 3] [3 4]]))</strong>, the symbol <strong>reverse</strong>
        actually denotes a function. </font></p>
        <p align="left"><font size="2" face="Verdana">That means
        in the Lisp family, symbols are semantically context
        sensitive. At the head of an application they can only
        denote a function and there is no ambiguity; but within
        the body of the application they can denote either a
        function or the symbol quoted. Lets us say a symbol is<strong>
        idle</strong> in Qi if it is used without naming
        anything.</font></p>
        <p align="left"><font size="2" face="Verdana">To help
        reading, Common Lisp includes the expression <strong>function</strong>
        which disambiguates idle symbols from the other kind; the
        expression <strong>(mapcar (function reverse) '((1 2) (2
        3) (3 4))) </strong>does what <strong>(mapcar 'reverse
        '((1 2) (2 3) (3 4)))</strong> does but the semantics of <strong>reverse</strong>
        is clarified to show that the programmer is referring to
        the function not the symbol itself.</font></p>
        <p align="left"><font size="2" face="Verdana">Qi I and Qi
        II followed Common Lisp in making symbols semantically
        context sensitive, relying on the Common Lisp compiler to
        decipher the ambiguity and make the correct choice. Being
        specifically tailored for multiplatform development, Shen
        can make no such assumption. It is quite possible that
        the native platform does not support symbols as data
        objects in the manner of Lisp; in which case it is
        possible to construct a simulation of Lisp symbols by
        using tagged 2 element vectors (one element a tag to show
        it is impersonating a symbol, the other to hold a string
        representation of the symbol; see <strong>Coping with
        Missing Symbols</strong> in the document of porting). </font></p>
        <p align="left"><font size="2" face="Verdana">However the
        problem arises of the context sensitivity of symbols;
        when should a symbol should be 'vectorised' in a non-Lisp
        language and when not? For instance, if the symbol <strong>reverse</strong>
        is vectorised in the context <strong>(map reverse [[1 2]
        [2 3] [3 4]])</strong>, then the <strong>map</strong>
        function will crash, since it receives a vector and not a
        function as an argument. But in the context <strong>[John
        put the car into reverse]</strong>, it is right to
        vectorise the symbol <strong>reverse</strong> because it
        is not calling a function. How does one proceed?</font></p>
        <p align="left"><font size="2" face="Verdana">There are
        several solutions to this problem. One is to simply avoid
        idle symbols and insist that strings do all the work of
        idle symbols. This follows the path of languages like ML
        where idle symbols do not exist. It would mean that in
        Shen, <strong>[p &amp; q] </strong>could not be written;
        only <strong>[&quot;p&quot; &quot;&amp;&quot;
        &quot;q&quot;]</strong>. However this would probably not
        appeal to those Lispers, like myself, who enjoy the
        convenience of working with idle symbols.</font></p>
        <p align="left"><font size="2" face="Verdana">The second
        is to treat all non-variable symbols in the body of an
        application (apart from the leading symbol which must
        denote a function or procedure of some form) as idle,
        thus vectorising them. In this case, to prevent any
        higher-order function H from failing, H must, when
        applying any vectorised symbol S, look for the function F
        associated with S and use F instead. This introduces a
        delay into the execution of H and moreover means that
        native higher-order functions in the platform, which are
        not set up to interface to vectorised symbols, will still
        fail in the manner described above.</font></p>
        <p align="left"><font size="2" face="Verdana">The third
        solution is to provide '<strong>function</strong>' as a
        means of disambiguation and this is what Shen does. Hence
        any symbol S which is an argument to an application is
        treated as idle. But if S is enclosed as in '(function
        S)', the whole expression denotes a function. <em><u>Hence
        to write portable Shen; one should avoid writing an
        expression like '</u></em><strong><u>(map reverse [[1 2]
        [2 3] [3 4]])</u></strong><em><strong><u>'</u></strong></em><em><u>
        and write </u></em><u>'</u><strong><u>(map (function
        reverse) [[1 2] [2 3] [3 4]])</u></strong><u>'</u>. The
        former construction will certainly work under a Common
        Lisp platform, but the latter will run under Common Lisp
        and platforms outside the Lisp family.</font></p>
        <p align="left"><font size="2" face="Verdana">Note in
        version 18 and after, <strong>function </strong>is
        statically compiled away where possible in favour of a
        lambda form (<strong>(function union)</strong> is <strong>(/.
        X Y (union X Y))</strong>). When this is not possible,
        because <strong>function</strong> is used dynamically, a
        lookup table is used to find the appropriate lambda form.
        zero-place functions are not admissable arguments to <strong>function</strong>.</font></p>
        <p align="left"><a name="Packages"></a><font size="3"
        face="Verdana"><strong>Packages </strong></font></p>
        <p align="left"><font size="2" face="Verdana">Packages
        exist to avoid the usual danger of overwriting when two
        programmers accidently choose the same symbols in their
        programs to identify different values. The polyadic
        function <strong>package</strong> has the form <strong>(package
        S L E</strong><sub><strong>1</strong></sub><strong> ... E</strong><sub><strong>n</strong></sub><strong>)
        </strong>where</font></p>
        <p align="left"><font size="2" face="Verdana">1. <strong>S</strong>
        is a symbol beginning in lowercase which is the name of a
        package; (e.g <strong>mypackage</strong>).<br>
        2. A list <strong>L</strong> (possibly empty) of
        non-variable symbols. <br>
        3.<strong> E</strong><sub><strong>1</strong></sub><strong>
        ... E</strong><sub><strong>n</strong></sub> are a series
        of Shen expressions.</font></p>
        <p align="left"><font size="2" face="Verdana">The Shen
        reader prepends the package symbol S followed by dot (<strong>.</strong>)
        before all the symbols when evaluating <strong>E</strong><sub><strong>1</strong></sub><strong>
        ... E</strong><sub><strong>n</strong> </sub>apart from
        those symbols which are <strong>external</strong>, which
        are</font></p>
        <p align="left"><font size="2" face="Verdana">(a) symbols
        listed as belonging to the system (such as <strong>-&gt;</strong>,
        <strong>define</strong>, <strong>cons</strong>, <strong>append</strong>
        etc) or ... These are in fact the external symbols of the
        Shen package in which Shen is coded and may be called up
        by the expression <strong>(external shen)</strong>. <br>
        (b) symbols which are variables or ...<br>
        (c) ... symbols which are listed in <strong>L</strong> or
        .....<br>
        (d) ... symbols internal to the Shen package (<strong>shen</strong>)
        or ....<br>
        (e) ... symbols consisting entirely of underscores or
        entirely of equals signs.<br>
        (f) ... symbols already packaged under S (a rule
        introduced in Shen 19).</font></p>
        <p align="left"><font size="2" face="Verdana">Symbols
        which are prepended we say are <strong>internal</strong>
        (to the package). Symbols which are not are <strong>external</strong>.
        </font></p>
        <p align="left"><font size="2" face="Verdana">Hence <strong>(package
        mypackage [main] (define main ...) ....)</strong> will
        cause Shen to make all user functions read in its scope
        to be internal to <strong>mypackage</strong> apart from
        the symbol <strong>main</strong> which will be external. </font></p>
        <p align="left"><font size="2" face="Verdana">The
        philosophy of Shen is that once a programmer has decided
        a symbol is internal to a package and is hidden from view
        that decision cannot be overridden except by changing the
        definition of the package. Hence the complexities of <strong>IMPORT</strong>
        and <strong>EXPORT</strong> found in Common Lisp are not
        reproduced in Shen. You cannot be 'in' a package in Shen
        within the REPL. It is possible to declare a package in a
        package.</font></p>
        <p align="left"><font size="2" face="Verdana">The <strong>null
        package</strong> written <strong>(package null ....)</strong>
        has no effect on its contents. This used in certain
        advanced applications involving reader macros.</font></p>
        <p align="left"><font size="2" face="Verdana">The
        function <strong>external</strong> takes a package name
        and returns the list of all those symbols which have been
        declared external to that package at the point the
        function is called. If the package does not exist, an
        error is raised.</font></p>
        <p align="left"><font size="2" face="Verdana">The
        function <strong>internal</strong> takes a package name
        and returns the list of all those symbols which have been
        found to be internal to that package at the point the
        function is called. If the package does not exist, an
        error is raised. This function was introduced in Shen 19.</font></p>
        <p align="left"><font size="2" face="Verdana">Note that
        Shen will allow you to reference symbols that are
        internal to a package by citing the package name (e.g. <strong>mypackage.foo</strong>).
        </font></p>
        <p align="left"><font size="2" face="Verdana">Symbols
        which are external to the Shen package may not be
        redefined; the user cannot redefine <strong>append</strong>
        for instance. The function <strong>systemf </strong>of
        type <strong>symbol --&gt; symbol</strong> applied to any
        symbol gives that symbol the authority of an external
        symbol of the Shen package and the functional definition
        attached to that symbol cannot thereafter be overwritten.
        From version 17, <strong>systemf </strong>returns its
        argument.</font></p>
        <p align="left"><font size="2" face="Verdana">Version 17
        introduced <strong>package?</strong> of type <strong>symbol
        --&gt; boolean</strong> which returns <strong>true</strong>
        when the package exists and <strong>false</strong>
        otherwise. </font></p>
        <p align="left"><a name="Prolog"></a><font size="3"
        face="Verdana"><strong>Prolog</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Shen
        contains a Prolog, just as Qi II, but the <strong>m-prolog</strong>
        syntax has been dropped. The main reason for this was
        that embedding executable code in a string (to preserve
        conformancy with Edinburgh syntax) generated awkward
        anomalies with respect of the rest of the system. For
        example a special string searching routine had to be
        developed for <strong>m-prolog</strong> declarations
        embedded in a package; symbol overloading had to be used
        because Edinburgh Prolog uses '=' to mean something
        different from simple equality; you cannot insert
        comments inside an <strong>m-prolog</strong> program and
        searching in an <strong>m-prolog</strong> program is more
        difficult since the structure is in a string not a list.
        To compensate Qi developed a low level <strong>s-prolog</strong>
        convention in which Prolog programs were s-exprs.</font></p>
        <p align="left"><font size="2" face="Verdana">In place of
        the awkward dual convention, Shen has one Prolog notation
        consistent with the rest of Shen which uses <strong>defprolog.
        </strong>Here are the member, reverse and append
        functions in Shen Prolog.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defprolog
        member<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>X [X | _] &lt;--;<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>X [_ | Y] &lt;-- (member X Y);)</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defprolog
        rev<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>[] [] &lt;--;<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>[X | Y] Z &lt;-- (rev Y W) (conc W
        [X] Z);)</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defprolog
        conc<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>[] X X &lt;--;<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>[X | Y] Z [X | W] &lt;-- (conc Y Z
        W);)</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        following functions are found in Shen Prolog</font></p>
        <table border="0">
            <tr>
                <td align="center"><font size="2" face="Verdana"><strong>predicate</strong></font></td>
                <td align="center"><font size="2" face="Verdana"><strong>arity</strong></font></td>
                <td align="center"><font size="2" face="Verdana"><strong>description</strong></font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">unify</font></td>
                <td align="center"><font size="2" face="Verdana">2</font></td>
                <td><font size="2" face="Verdana">unifies terms</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">unify!</font></td>
                <td align="center"><font size="2" face="Verdana">2</font></td>
                <td><font size="2" face="Verdana">unifies terms
                with an occurs check</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">identical</font></td>
                <td align="center"><font size="2" face="Verdana">2</font></td>
                <td><font size="2" face="Verdana">succeeds if the
                terms are identical</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">is</font></td>
                <td align="center"><font size="2" face="Verdana">2</font></td>
                <td><font size="2" face="Verdana">binds the
                variable which is the first term to the result of
                evaluating the second. All variables in the
                second are completely dereferenced.</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">bind
                </font></td>
                <td align="center"><font size="2" face="Verdana">2</font></td>
                <td><font size="2" face="Verdana">as 'is' except
                all variables in the second term are dereferenced
                only so far as to derive a non-variable result.</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">findall</font></td>
                <td align="center"><font size="2" face="Verdana">3</font></td>
                <td><font size="2" face="Verdana">takes a
                variable X , a literal (list) L and a variable Y
                and finds all values for X in L for which L is
                provable and binds the list of these values to Y.</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">when</font></td>
                <td align="center"><font size="2" face="Verdana">1</font></td>
                <td><font size="2" face="Verdana">the term is
                evaluated to true or false and the call succeeds
                if it is true. All variables in the term are
                completely dereferenced.</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">fwhen</font></td>
                <td align="center"><font size="2" face="Verdana">1
                </font></td>
                <td><font size="2" face="Verdana">the term is
                evaluated to true or false and the call succeeds
                if it is true. All variables in the term are
                dereferenced only so far as to derive a
                non-variable result.</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">call</font></td>
                <td align="center"><font size="2" face="Verdana">1</font></td>
                <td><font size="2" face="Verdana">apply the
                predicate at the head of the list to the terms of
                the tail. (Prolog apply)</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">return</font></td>
                <td align="center"><font size="2" face="Verdana">1</font></td>
                <td><font size="2" face="Verdana">terminate
                Prolog returning the dereferenced value of the
                term.</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">!</font></td>
                <td align="center"><font size="2" face="Verdana">0</font></td>
                <td><font size="2" face="Verdana">Prolog cut</font></td>
            </tr>
            <tr>
                <td align="center"><font size="2" face="Verdana">receive</font></td>
                <td align="center"><font size="2" face="Verdana">1</font></td>
                <td><font size="2" face="Verdana">Bind a variable
                to a value outside of Prolog</font></td>
            </tr>
        </table>
        <p align="left"><font size="2" face="Verdana"><strong>receive
        </strong>was introduced in version 14 to allow Prolog to
        be called with a variable whose binding is made outside
        Prolog. Thus <strong>(foo a) </strong>in</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        foo<br>
        X -&gt; (prolog? (receive X) (bar X X)))</strong></font></p>
        <p align="left"><font size="2" face="Verdana">will call <strong>(bar
        a a)</strong> inside Prolog.</font></p>
        <p align="left"><a name="Shen-YACC II"></a><font size="3"
        face="Verdana"><strong>Shen-YACC II</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Shen
        contains a YACC, just as Qi II, but the syntax was
        modified in 9.0 to bring it closer to Shen. This section
        briefly describes the differences.</font></p>
        <p align="left"><font size="2" face="Verdana">The <strong>-*-</strong>
        (ditto <strong>-s-</strong> and <strong>-o-</strong>)
        indicating the head of the input stream is gone from YACC
        II and just as in Shen variables mark the position of
        isolated elements. This makes for a more powerful and
        flexible notation. The use of <strong>(fail)</strong> in
        a semantic action to trigger backtracking is dropped in
        favour of a guard. Thus the following tests a list of
        numbers to determine if the list is binary</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defcc
        &lt;binary?&gt;<br>
        X &lt;binary?&gt; := true where (element? X [0 1]);<br>
        X := true where (element? X [0 1]);<br>
        &lt;e&gt; := false;)</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>&lt;!&gt;
        </strong>consumes the remaining input.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defcc
        &lt;tl&gt;<br>
        _ &lt;!&gt; := &lt;!&gt;;)</strong></font></p>
        <p align="left"><font size="2" face="Verdana">returns the
        tail of a list. Shen-YACC II recognises lists in the
        input.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defcc
        &lt;asbs&gt;<br>
        [a b] &lt;asbs&gt;;<br>
        [a b];)</strong></font></p>
        <p align="left"><font size="2" face="Verdana">recognises
        lists of the form <strong>[[a b]], [[a b] [a b]], ....</strong></font></p>
        <p align="left"><a name="Strings"></a><font size="3"
        face="Verdana"><strong>Strings, Bytes and Unicode</strong></font></p>
        <p align="left"><font size="2" face="Verdana">A string in
        Shen begins with &quot; and ends with &quot;. The basic
        functions for strings are <strong>cn</strong> - which
        concatenates two strings together, <strong>pos</strong>,
        which takes a non-negative number N (starting from zero)
        and returns the Nth unit string of the string and <strong>tlstr
        </strong>which returns all of the string apart from its
        leading unit string. The function <strong>str</strong>
        places an atom into a string (effectively enclosing it in
        quotes). </font></p>
        <p align="left"><font size="2" face="Verdana">The action
        of <strong>str </strong>within the domain of atoms is as
        follows (^ is the concatenation sign).</font></p>
        <ol>
            <li><p align="left"><font size="2" face="Verdana">For
                a symbol S, <strong>str</strong> returns the
                string &quot;^S^&quot; that results from
                enclosing it in quotes.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">For
                a number N, <strong>str</strong> returns a string
                &quot;^M^&quot; whose contents M are such that (=
                M N) is true in Shen. <strong>str</strong>
                applied to a large floating point number may
                return a string whose contents are in e number
                notation.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">For
                a string S, <strong>str</strong> returns a string
                that when printed off reads as &quot;^S^&quot;.
                However the internal representation of the string
                may and probably will differ from its print
                representation.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">For
                the failure object, <strong>str</strong> returns <strong>&quot;...&quot;</strong></font></p>
            </li>
        </ol>
        <p align="left"><font size="2" face="Verdana">In earlier
        versions of Shendoc (&lt; 6.1) the question of the print
        representation of streams and closures was not
        determined. In fact these objects are sent to <strong>str</strong>
        in the course of printing and hence the print
        representation of streams and closures depends directly
        on their string representation under <strong>str</strong>.
        In point of fact it is frequently impossible to recover
        the original expression that evaluated to the
        stream/closure and so generally their print
        representation is not readable. In these cases <strong>str</strong>
        should use the platform representation unless this is
        totally confusing. </font></p>
        <p align="left"><font size="2" face="Verdana">A more
        general function <strong>make-string</strong> will place
        any Shen object into a string, preserving the appearance
        in a way that makes it conformant to Shen printing
        conventions (see printing). <strong>string?</strong>
        recognises all and only strings.</font></p>
        <p align="left"><font size="2" face="Verdana">The Shen
        reader reads unsigned 8 bit bytes into unit strings and
        parses these strings into other tokens as required. By
        default the list of acceptable unsigned bytes is a subset
        of the ASCII code points between 0 and 127, including all
        the points from 32 to 126 and the points 9,10 and 13. The
        function <strong>n-&gt;string</strong> maps a code point
        to the corresponding unit string. It is consistent with
        the Shen specification to extend the domain of this
        function to incorporate extended ASCII or Unicode, but
        the mentioned code points must be supported. The function
        <strong>string-&gt;n</strong> is the inverse of <strong>n-&gt;string</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">The <strong>$</strong>
        notation as in <strong>($ hello)</strong> is read in by
        the reader by exploding its argument. <strong>($ hello) </strong>is
        read in as <strong>&quot;h&quot; &quot;e&quot;
        &quot;l&quot; &quot;l&quot; &quot;o&quot;</strong>; this
        was introduced as a convenient shorthand for writing
        string handling programs. Note <strong>$</strong> is not
        a function.</font></p>
        <p align="left"><font size="2" face="Verdana">Shen uses
        decimal notation for reading bytes and for character
        codes. The character string <strong>&quot;c#67;&quot;</strong>
        will be printed as <strong>&quot;C&quot;</strong>. </font></p>
        <p align="left"><a name="Strings and Pattern Matching"></a><font
        size="3" face="Verdana"><strong>Strings and Pattern
        Matching</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        polyadic function <strong>@s</strong> can be used to
        concatenate n (n &gt;= 2) strings. The polyadicity is a </font><a
        href="http://www.lambdassociates.org/Book/page397.htm"><font
        size="2" face="Verdana">syntactic fiction </font></a><font
        size="2" face="Verdana">maintained by the Shen reader.
        (@s &quot;a&quot; &quot;b&quot; &quot;c&quot;) is parsed
        as (@s &quot;a&quot; (@s &quot;b&quot; &quot;c&quot;))
        exactly in the manner of @p. </font></p>
        <p align="left"><font size="2" face="Verdana">The Shen
        reader parses (@s &quot;123&quot; &quot;456&quot;) in a
        special way; as (@s &quot;1&quot; (@s &quot;2&quot; (@s
        &quot;3&quot; &quot;456&quot;))). The leading argument,
        if a string, is decomposed into a series of
        concatenations of unit strings. The significance of this
        is realised in the use of @s for pattern-matching over
        strings.</font></p>
        <p align="left"><font size="2" face="Verdana">@s is not a
        fast operation because many platforms represent strings
        as vectors and in these cases @s runs in linear time in
        respect of the size of the arguments.</font></p>
        <p align="left"><font size="2" face="Verdana">Within a
        function @s may be used for pattern-matching. For
        example; the following removes all occurences of my
        Christian name from a string.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        remove-my-name <br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font
        color="#000000" size="2" face="Verdana"><strong>{string
        --&gt; string}</strong></font><font color="#FFFFFF"
        size="2" face="Verdana"><strong><br>
        xx</strong></font><font size="2" face="Verdana"><strong>&quot;&quot;
        -&gt; &quot;&quot;<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>(@s &quot;Mark&quot; Str) -&gt;
        (remove-my-name Str)<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>(@s S Str) -&gt; (@s S
        (remove-my-name Str)))</strong></font></p>
        <p align="left"><font size="2" face="Verdana">which is
        parsed into the following.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        remove-my-name <br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font
        color="#000000" size="2" face="Verdana"><strong>{string
        --&gt; string}<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>&quot;&quot; -&gt; &quot;&quot;<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>(@s &quot;M&quot; (@s
        &quot;a&quot; (@s &quot;r&quot; (@s &quot;k&quot; Str))))
        -&gt; (remove-my-name Str)<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>(@s S Str) -&gt; (@s S
        (remove-my-name Str)))</strong></font></p>
        <p align="left"><a name="Lists"></a><font size="3"
        face="Verdana"><strong>Lists</strong></font></p>
        <p align="left"><font size="2" face="Verdana">In Shen as
        in Qi, a list consists of a series of items, seperated by
        whitespace, and flanked by [ and ] to the left and right.
        [] is the empty list as is (). Note that K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> does not understand [...] and that the
        Shen reader translates this idiom into K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana">. The basic constructors are <strong>cons</strong>,<strong>
        hd</strong> and <strong>tl</strong> and <strong>cons?</strong>
        corresponding to CONS, CAR and CDR, and CONSP in Lisp.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>It
        is an error to apply hd or tl to anything but a list. </strong></font></p>
        <p align="left"><font size="2" face="Verdana">There is
        the question of how to treat the application of <strong>hd</strong>
        to the empty list <strong>[]</strong>. Ideally this
        should produce an error. In Common Lisp the CAR of the
        empty list is the empty list. Actually coding <strong>hd</strong>
        so that it returns an error in Common Lisp requires
        encoding a non-empty list test into the definition of <strong>hd</strong>.
        This is generally unnecessarily expensive in such a
        heavily utilised function, because often the programmer
        knows before applying <strong>hd</strong> that the list
        is non-empty. Hence in Shen <strong>hd</strong> does not
        presuppose a non-empty list test and the result of
        applying<strong> hd </strong>to the empty list is
        platform dependent. For implementors building K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> from scratch we recommend raising an
        error, as applying <strong>hd</strong> to the empty list
        is a deprecated operation.</font></p>
        <p align="left"><font size="2" face="Verdana">For that
        reason in Shen, <strong>hd</strong> is not given a type
        since its behaviour is type unpredictable. There is a
        function <strong>head</strong> of type (list A) --&gt; A
        in Shen which is well-behaved and which does make a
        non-empty list test and which raises an error if applied
        to the empty list. </font></p>
        <p align="left"><font size="2" face="Verdana">Similar
        observations apply to <strong>tl</strong> which if
        applied to the empty list in Common Lisp produces an
        empty list. In other languages, an error may arise. Hence
        by parity of reasoning, the result of <strong>(tl ())</strong>
        is platform dependent and there is no type for <strong>tl</strong>.
        There is a function <strong>tail</strong> of type <strong>(list
        A) --&gt; (list A)</strong> in Shen which is well-behaved
        and which does make a non-empty list test and which
        raises an error if applied to the empty list. </font></p>
        <p align="left"><font size="2" face="Verdana">Note that <strong>cons</strong>
        applied to X and Y where Y is not a list provides a
        result which is called a <strong>dotted pair</strong>. <em><u>This
        form of application is needed in Shen in the internals of
        Shen Prolog</u></em>. In Shen <strong>cons </strong>does
        have a type because the type checker is capable of
        failing dotted pair applications as type insecure. Hence
        the type of <strong>cons</strong> is <strong>A --&gt;
        (list A) --&gt; (list A)</strong>. In Shen, the dotted
        pair <strong>(cons a b)</strong> is printed off as <strong>[a
        | b]</strong>.</font></p>
        <p align="left"><a name="Characters"></a><font size="3"
        face="Verdana"><strong>Characters</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Shen does
        not incorporate characters as a data type. The failure
        object is no longer <strong>#\Escape</strong> as in Qi,
        but <strong>(fail)</strong>. The exact identity of the
        failure object in a platform is not determined but it
        should be some unique object within the type <strong>symbol</strong>.
        </font></p>
        <p align="left"><a name="Streams"></a><font size="3"
        face="Verdana"><strong>Streams</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Streams in
        Shen were introduced to encode some of the functions that
        were hard-wired into Qi II like <strong>write-file</strong>
        and <strong>read-file</strong>. The goal was to capture
        just as much in the way of primitives as is necessary to
        reproduce the functionality of Qi II. From Shen 13
        onwards only byte streams are supported by the standard.
        Any other kind of stream will be found in a library.</font></p>
        <p align="left"><font size="2" face="Verdana">The basic
        functions for streams are</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>open<br>
        close<br>
        read-byte<br>
        write-byte<br>
        stinput<br>
        stoutput</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        function <strong>open </strong>creates a stream and the
        first argument is a string designating the file which is
        the basis of the stream and the second argument is either
        <strong>in</strong> or <strong>out</strong> determines
        whether the resulting stream is a source or sink .
        Material written to a file overwrites the contents
        already in it. The function <strong>close</strong> closes
        a stream and returns the empty list. </font></p>
        <p align="left"><font size="2" face="Verdana">The <strong>open</strong>
        function works in hand with the <strong>cd</strong>
        command in Shen which fixes the home directory. All files
        are opened relative to the value for the home directory,
        which is held in the global <strong>*home-directory*</strong>.
        The value of this global is changed by the <strong>cd</strong>
        function common to Qi and Shen.</font></p>
        <p align="left"><font size="2" face="Verdana">Every Shen
        stream is read in or written to as a series of <strong>unsigned
        8 bit bytes</strong>. <strong>read-byte</strong> takes a
        source stream as an argument and returns a byte as a
        decimal number between 0 and 255. If the stream is empty
        then <strong>read-byte</strong> returns -1. Having such
        base reader, it is possible to build any reader on top of
        it. A UTF-8, UTF-16 or UTF-32 stream reader may be built
        from 8 bit bytes stream reader. <strong>read-byte</strong>
        is a polyadic function which can appear with no
        arguments; in that case the stream read is the standard
        input (terminal) stream <strong>(stinput)</strong>. </font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(stinput)</strong>
        returns the standard input as a byte source. If <strong>read-byte</strong>
        is applied to the standard input then the user's input is
        echoed to the terminal under the printing convention that
        the character printed has the same code point as the byte
        (as in UTF-8). Effectively this means that <strong>(stinput)
        </strong>may handle extended ASCII, although only ASCII
        is required of the Shen reader.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>write-byte
        </strong>writes a byte as a number <em>n</em> from 0 to
        255 to a stream and returns <em>n</em> as a value. If the
        stream is omitted then <strong>write-byte</strong>
        defaults to the standard output. If <strong>write-byte</strong>
        is applied to the standard output then the user's input
        is echoed to the terminal under the printing convention
        that the character printed has the same code point as the
        byte. <strong>(stoutput)</strong> returns the standard
        output.</font></p>
        <p align="left"><font size="2" face="Verdana">The type <strong>stream</strong>
        is a parametric type in Shen and has only two possible
        parameters - <strong>in</strong> or <strong>out</strong>.
        The type of the <strong>open</strong> function is a
        dependent type which cannot be given a type in arrow
        notation but requires the following sequent calculus
        definition.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong><u>File
        : string; <br>
        </u></strong><strong>(open File Direction) : (stream
        Direction);</strong></font></p>
        <p align="left"><font size="2" face="Verdana">where the
        values of <strong>Direction</strong> are 'in' and 'out'.</font></p>
        <p align="left"><font size="2" face="Verdana">In Shen 16
        the zero-place function <strong>it</strong> was
        introduced; <strong>(it)</strong> returns the last
        (unevaluated) expression entered to the standard input as
        a string. The type of <strong>it</strong> is <strong>(--&gt;
        string)</strong>.</font></p>
        <p align="left"><a name="Reader Macros"></a><font
        size="3" face="Verdana"><strong> Reader Macros</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The Shen
        reader sits on top of the primitive bytes stream reader
        and reads from either a file (using <strong>open</strong>)
        or the input stream. The reader is programmable just as
        in Qi II, but uses the <strong>defmacro</strong>
        construction, which is actually cleaner and easier to use
        than the Qi II <strong>sugar</strong> function. However
        internally, the <strong>defmacro</strong> construction is
        handled using similar techniques as for sugar functions.
        A macro in Shen is a 1-place function that is used by the
        reader to parse the user input. Here for instance is a
        macro used for benchmarking Shen.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defmacro
        exec-macro<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>[exec Expr] -&gt; [trap-error
        [time Expr] [/. E failed]])</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The action
        of this macro is to macroexpand every instance of <strong>(exec
        Expr)</strong> as typed or loaded into the top level by
        the macroexpansion of <strong>(trap-error (time Expr) (/.
        E failed))</strong>. There is no need to include a
        default <strong>X -&gt; X</strong> at the bottom of a
        macro (as is needed in Qi II) - this is inserted
        automatically. Shen macros are tied into the Shen <strong>eval</strong>
        function (see eval below). The function <strong>macroexpand</strong>
        applies the list of current macros to the top level of an
        expression.</font></p>
        <p align="left"><font size="2" face="Verdana">The mode of
        operation of <strong>macroexpand</strong> within the
        reader and within <strong>eval</strong> is as follows. </font></p>
        <ol>
            <li><p align="left"><font size="2" face="Verdana">Within
                the reader: the list of macros is composed to a
                fixpoint on every read token <em>t</em> (i.e.
                atom or list of atoms). If the token <em>t</em>
                is changed to <em>t</em>' where <em>t</em>
                &lt;&gt; <em>t</em>', the process is repeated on
                every subterm of <em>t</em>'.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">Within
                <strong>eval</strong>; the list of macros is
                composed on every subterm (i.e. atom or list of
                atoms) to a fixpoint.</font></p>
            </li>
        </ol>
        <p align="left"><a name="Vectors"></a><font size="3"
        face="Verdana"><strong>Vectors</strong></font></p>
        <p align="left"><font size="2" face="Verdana">In K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> and Shen, (1 dimensional) vectors fulfil
        all the tasks of arrays. In K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">
        there are only 4 primitive functions concerned with
        vectors.</font></p>
        <p align="left"><font size="2" face="Verdana">1. <strong>absvector
        </strong>- which creates an absolute (platform) vector
        with N addresses.<br>
        2. <strong>address-&gt;</strong> - which destructively
        places an element E into a vector address N in vector V
        and returns the resultant vector.<br>
        3. <strong>&lt;-address</strong> - which extracts an
        element from a vector address N in vector V.<br>
        4. <strong>absvector?</strong> which recognises a vector.</font></p>
        <p align="left"><font size="2" face="Verdana">All of
        these functions are accessible from Shen but only the
        last has a type, since K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">
        vectors may have elements of any type. It is an error to
        try to access an address beyond the limit of the vector
        or to supply any number which is not a whole number
        between 0 and the limit of the vector. </font></p>
        <p align="left"><font size="2" face="Verdana">Note that <strong>absvector?</strong>
        plugs into the native vector recognition routine. It is
        possible for this function to return true to objects
        which are not vectors under other platfroms. In Lisp for
        instance, strings are vectors of characters and the
        default representation of tuples in Shen is by use of
        vectors. The function <strong>vector? </strong>(see
        below) is better behaved in this respect.</font></p>
        <p align="left"><font size="2" face="Verdana">Vectors are
        numbered from 0; so <strong>(absvector 100) </strong>creates
        a vector with addresses from 0 to 99.</font></p>
        <p align="left"><font size="2" face="Verdana">If a vector
        V is created and nothing has been stored address V(N)
        then the result returned by <strong>(&lt;-address V N) </strong>is
        platform dependent.</font></p>
        <p align="left"><font size="2" face="Verdana">In Shen
        absolute vectors are partioned into standard and
        non-standard vectors. In Shen, by convention, when a <strong>standard
        vector</strong> V is created two operations are
        performed.</font></p>
        <p align="left"><font size="2" face="Verdana">1. The 0th
        element of V is allocated a positive integer which
        indicates the size (limit) of the vector. <br>
        2. Every other address is allocated the <em>failure
        object</em> designated by the expression <strong>(fail)</strong>.
        </font></p>
        <p align="left"><font size="2" face="Verdana">The
        function <strong>vector</strong> of type number --&gt;
        (vector A) creates such a vector. If the 0th element of V
        is not a non-negative integer then the vector is <strong>non
        standard</strong>. Hence access to the user contents of
        the standard vector begins with the index N = 1.</font></p>
        <p align="left"><font size="2" face="Verdana">The
        shortest standard vector is created by expression <strong>(vector
        0) </strong>which creates a standard vector which
        contains one element whose contents are zero. This called
        the <strong>empty vector</strong> and is significant in
        pattern-matching over vectors (see next section). It is
        impossible to write to the empty vector in a type secure
        way and hence under type security, the empty vector is
        immutable. Shen permits the user to write <strong>&lt;&gt;
        </strong>as shorthand for the empty vector. The type of
        the empty vector is <strong>(vector A)</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">In K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> the primitive function <strong>&lt;-address
        </strong>in <strong>(&lt;-address N V) </strong>accesses
        the Nth element of the vector V including the 0th element
        which indicates the limit of the vector. This function
        has no type because the 0th element of a standard vector
        V will be an integer irrespective of the rest of the
        vector.</font></p>
        <p align="left"><font size="2" face="Verdana">The type
        secure version of <strong>&lt;-address</strong> is the
        function <strong>&lt;-vector</strong> of type (vector A)
        --&gt; number --&gt; A, which accesses the contents of
        the standard vector. The operation (<strong>&lt;-vector</strong>
        V 0) results in an error. If <strong>&lt;-vector</strong>
        accesses the <em>failure object</em> then an exception is
        returned as an error message. Otherwise <strong>&lt;-vector</strong>
        behaves exactly as does <strong>&lt;-address</strong>.
        The function <strong>limit</strong> has the type (vector
        A) --&gt; number and accesses the 0th element of a
        standard vector V. Both are simply defined in terms of <strong>&lt;-address</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">A
        2-dimensional array is simply a vector of vectors and
        therefore has a type which is an instance of (vector
        (vector A)). Note that a vector of vectors may
        incorporate vectors of different sizes (the result is
        called a <strong>jagged array</strong>).</font></p>
        <p align="left"><font size="2" face="Verdana">For
        changing the contents of a vector, the function <strong>address-&gt;
        </strong>in (address-&gt; X N V) places X in the Nth
        element of V. The function <strong>vector-&gt;</strong>
        is type secure version of <strong>address-&gt; </strong>of
        type ((vector A) --&gt; number --&gt; A --&gt; (vector A)
        and raises an error for N = 0. </font></p>
        <p align="left"><font size="2" face="Verdana">The
        function <strong>vector?</strong> returns true iff the
        argument is a standard vector. </font></p>
        <p align="left"><a
        name="Standard Vectors and Pattern Matching"></a><font
        size="3" face="Verdana"><strong>Standard Vectors and
        Pattern Matching</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        polyadic function <strong>@v</strong> can be used to add
        elements to a vector or to create a vector. The vector
        consisting of the numbers 1, 2 and 3 can be created by <strong>(@v
        1 2 3 &lt;&gt;)</strong>. The polyadicity is a </font><a
        href="http://www.lambdassociates.org/Book/page397.htm"><font
        size="2" face="Verdana">syntactic fiction</font></a><font
        size="2" face="Verdana"> maintained by the Shen reader. <strong>(@v
        1 2 3 &lt;&gt;) </strong>is parsed as <strong>(@v 1 (@ v
        2 (@v 3 &lt;&gt;)))</strong> exactly in the manner of <strong>@p</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">The
        semantics of <strong>@v</strong> is as follows: given <strong>(@v
        X Y)</strong>, if Y is a standard vector of size <strong>N</strong>,
        then <strong>@v</strong> creates and outputs a new vector
        V of size N+1 and places <strong>X</strong> in the first
        position of V, copying the Ith element of <strong>Y</strong>
        to the I+1 element of V. </font></p>
        <p align="left"><font size="2" face="Verdana">Shen
        accepts pattern-matching using <strong>@v</strong>. The
        following function adds 1 to every element of a vector</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        add1<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>{(vector number) --&gt; (vector
        number)}<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>&lt;&gt; -&gt; &lt;&gt;<br>
        </strong></font><font color="#FFFFFF" size="2"
        face="Verdana"><strong>xx</strong></font><font size="2"
        face="Verdana"><strong>(@v X Y) -&gt; (@v (+ X 1) (add1
        Y)))</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(@v
        X Y)</strong> matches the <strong>Y</strong> to the tail
        of the vector - so that matching <strong>(@v X Y) </strong>to
        &lt;1 2&gt; matches Y to &lt;2&gt; not 2. Note because <strong>@v</strong>
        uses copying, pattern-directed vector manipulation is
        non-destructive but slow.</font></p>
        <p align="left"><a name="Tuples"></a><font size="3"
        face="Verdana"><strong>Non Standard Vectors and Tuples</strong></font></p>
        <p align="left"><font size="2" face="Verdana">A
        non-standard vector is a vector where the 0th element is
        not a non-negative integer. The utility of non-standard
        vectors is that they can be used to construct other data
        types like <strong>tuples</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">Tuples in
        Shen are not primitive to K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana"> but
        are represented in the Shen sysfile code as non-standard
        three element vectors where the 0th element is a tag <strong>tuple</strong>
        indicating that the vector represents a tuple and the
        next two elements are the first and second elements of
        that tuple. The basic operations such as <strong>@p</strong>,
        <strong>fst</strong> and <strong>snd</strong> are easily
        definable as is the recognisor <strong>tuple?</strong>. </font></p>
        <p align="left"><font size="2" face="Verdana">Because
        tuples are defined internally using K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> primitives as non-standard vectors, the
        type system of Shen does not recognise them as standard
        vectors and hence, though they can be manipulated using
        vector operations <u>they cannot be manipulated like this
        in a type secure way</u> (i.e. with type checking
        enabled). Only <strong>@p</strong>, <strong>fst</strong>
        and <strong>snd </strong>can be used. The significance of
        this is that with type checking enabled, tuples are <u>immutable
        objects</u>; that is they cannot be destructively changed
        with <strong>address-&gt; </strong>or <strong>vector-&gt;</strong>,
        merely interrogated for their parts or combined into
        other data structures.</font></p>
        <p align="left"><font size="2" face="Verdana"><em>The
        identity of tuples with non-standard vectors is purely
        one of convenience.</em> In platforms which support
        tuples as a native type, the native type may be used.
        However the following equations must hold.</font></p>
        <ol>
            <li><p align="left"><font size="2" face="Verdana">The
                recognisor <strong>tuple?</strong> returns 'true'
                to tuples, but not to any other type checked Shen
                datatype.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">The
                tuple (@p 1 2) is printed off as such.</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana"><strong>@p</strong>
                is a two place function which associates to the
                right; (@p a b c) is just (@p a (@p b c)).</font></p>
            </li>
            <li><p align="left"><font size="2" face="Verdana">(fst
                (@p a b)) = a and (snd (@p a b)) = b for all a
                and b.</font></p>
            </li>
        </ol>
        <p align="left"><a name="Equality"></a><font size="3"
        face="Verdana"><strong>Equality</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>=</strong>
        tests for equality between objects, returning either true
        or false. Note unlike Qi II, = will work on all vectors
        generally; two vectors V<sub>1</sub> and V<sub>2</sub>
        are equal iff for all I (&lt;-address V<sub>1 </sub>I) =
        (&lt;-address V<sub>2</sub> I) . However comparison of
        closures or streams will return false under =. Lists,
        atoms, tuples and vectors are the proper range of this
        function. K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> is case sensitive, (= a A)
        returns false.</font></p>
        <p align="left"><a name="Priniting"></a><font size="3"
        face="Verdana"><strong>I/O</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Used to
        define all printing in Shen, is <strong>write-byte</strong>
        which takes a byte and a sink S and writes the byte to S.<strong>
        </strong>Higher level is<strong> pr</strong> which takes
        a string and a stream and prints the string to the stream
        and returns the string.<strong> </strong>If the stream
        argument in either case is omitted then the stream
        defaults to standard output. </font></p>
        <p align="left"><font size="2" face="Verdana">As with Qi,
        Shen includes the <strong>print</strong>, <strong>error</strong>
        and <strong>output</strong> statements in much the same
        way as in Qi II; they are explained here </font><a
        href="http://www.lambdassociates.org/Book/page042.htm"><font
        size="2" face="Verdana">http://www.lambdassociates.org/Book/page042.htm</font></a><font
        size="2" face="Verdana">. <strong>print</strong> prints
        its argument exactly as it appears and returns that
        argument, <strong>output</strong> prints a string using
        slots if needed and returns a string. Note in Shen, the
        slot ~S is supported as well as ~A. The effect of ~S (as
        in Common Lisp) is that string quoting is preserved. ~%
        forces a new line. Thus <strong>(output &quot;~A&quot;
        &quot;hello there&quot;) </strong>prints <strong>hello
        there</strong> but <strong>(output &quot;~S&quot;
        &quot;hello there&quot;)</strong> prints <strong>&quot;hello
        there&quot;</strong>. </font></p>
        <p align="left"><font size="2" face="Verdana">Note that <strong>output</strong>
        returns a string as a value which is the same string that
        it prints. </font></p>
        <p align="left"><font size="2" face="Verdana">Shen
        provides an extra formatting command ~R, which prints the
        argument using ()s rather than []s, which is useful for
        printing logical and mathematical formulae.</font></p>
        <p align="left"><font size="2" face="Verdana">All three
        functions depend on <strong>make-string</strong> which
        builds a string from a template and a series of
        arguments. Thus <strong>(make-string &quot;~A loves ~A
        and ~A&quot; John Mary Tim) </strong>returns <strong>&quot;John
        loves Mary and Tim&quot;</strong>. Use <strong>make-string</strong>
        to coerce an arbitrary object into a string. To write to
        a stream, you can use <strong>pr</strong> and <strong>make-string</strong>
        combined as in <strong>(pr (make-string &quot;~A loves ~A
        and ~A&quot; John Mary Tim) &lt;stream&gt;)</strong>. </font></p>
        <p align="left"><font size="2" face="Verdana">There is
        also a function <strong>(nl </strong><em><strong>N</strong></em><strong>)
        </strong>which prints off <strong>N</strong> new lines
        and returns zero. If the argument is omitted, then <strong>(nl)</strong>
        prints off a single new line.</font></p>
        <p align="left"><font size="2" face="Verdana">Note that <strong>print</strong>,
        <strong>error</strong>, <strong>output</strong> and <strong>make-string</strong>
        are all polyadic and that therefore they are syntactic
        fictions which are represented by internal functions of a
        fixed arity.</font></p>
        <p align="left"><font size="2" face="Verdana">Vectors and
        lists are printed off using &lt;...&gt;. The vector whose
        elements from address 1 to the end are <strong>1</strong>,
        <strong>2</strong> and <strong>3</strong> is printed off
        as <strong>&lt;1 2 3&gt;</strong>. Vectors or lists of
        more than 20 elements have the remaining elements printed
        off under '<strong>etc</strong>' e.g a standard vector of
        the first 100 positive integers would be printed off as</font></p>
        <p align="center"><font size="2" face="Verdana"><strong>&lt;1
        2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20...
        etc&gt;</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The global <strong>*maximum-print-sequence-size*</strong>
        controls this feature and should always be set to a
        positive whole number.</font></p>
        <p align="left"><font size="2" face="Verdana">Non-standard
        vectors are printed off in a special manner. For example,
        in porting Shen to a platform which lacked symbols as a
        basic datatype, the programmer can define symbol as a new
        immutable datatype comprised of a non-standard vector
        whose zeroth address holds a tag indicating that the
        vector represents a symbol and whose first address holds
        a string representing the symbol. </font></p>
        <p align="left"><font size="2" face="Verdana">In this
        case the programmer can indicate in the non-standard
        vector itself how the object is supposed to be printed
        off by making the tag into a print function. This is
        called a <strong>print vector</strong> in Shen. Thus the
        representation of the tuple (@p a b) in Shen is:</font></p>
        <div align="center"><center><table border="1"
        cellpadding="3" bordercolor="#000000">
            <tr>
                <td><font size="2" face="Verdana">tuple</font></td>
                <td><font size="2" face="Verdana">a</font></td>
                <td>b</td>
            </tr>
        </table>
        </center></div><p align="left"><font size="2"
        face="Verdana">The Shen printer, when confronted with a
        non-standard vector V whose 0th address contains a non
        positive integer F, uses F as as a <strong>formatting
        function - </strong>the function that determines how the
        non-standard vector is printed. This formatting function
        tells Shen how the print representation of V is to be
        bundled into the string which is eventually printed off
        and hence how that print vector will appear when printed.
        Hence the <strong>tuple</strong> function will map the
        tuple to a string. In Shen it is defined as follows.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        tuple <br>
        X -&gt; (make-string &quot;(@p ~S ~S)&quot; (fst X) (snd
        X)))</strong></font></p>
        <p align="left"><font size="2" face="Verdana">If the
        non-standard vector has no associated print function then
        it is printed off as a normal vector but with the 0th
        element included.</font></p>
        <p align="left"><font size="2" face="Verdana">The print
        representation of the failure object is <strong>...</strong>
        (three dots).</font></p>
        <p align="left"><font size="2" face="Verdana">The global
        variable <strong>*hush*</strong> is set by default to <strong>false</strong>.
        If set to <strong>true</strong> then all messages printed
        from <strong>output</strong> and <strong>print</strong>
        are disabled, through messages using <strong>pr</strong>
        will still be printed to the target stream. Effectively
        this disables system reports from Shen and all printing
        is then driven by the user. This feature was suggested by
        Ramil Farkshatov as an aid to diagnostics.</font></p>
        <p align="left"><font size="2" face="Verdana">The
        functions <strong>lineread</strong>, <strong>input</strong>,
        <strong>input+</strong>, <strong>read</strong> are in
        part adapted from Qi where they were all fixed to
        standard input. In version 13 of Shen these were made
        polyadic and relativised to an input stream. If no stream
        is chosen then Shen chooses standard input. The qualities
        of these functions are as follows.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>lineread
        </strong>reads in a line of Shen tokens terminated by a
        new line.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>read</strong>
        reads the first available Shen token</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>input</strong>
        reads the first available Shen token and evaluates it
        returning a normal form</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>input+</strong>
        receives a type T and a stream S and reads the first
        token off S, evaluates it and returns the normal form if
        that token is of type T. If the token is not of type T
        then an error is returned. Note that after Shen 13, <strong>(input+
        : number) </strong>is just written as <strong>(input+
        number)</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">All these
        functions return an error <strong>empty stream</strong>
        if the stream is empty.</font></p>
        <p align="left"><a name="Generic Functions"></a><font
        size="3" face="Verdana"><strong>Generic Functions</strong></font></p>
        <p align="left"><font size="2" face="Verdana">This
        section deals with the generic functions; <strong>defun</strong>,<strong>
        let</strong>,<strong> lambda</strong>,<strong> eval-kl</strong>,<strong>
        freeze </strong>and<strong> thaw</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>defun
        </strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>defun
        </strong>in K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> requires little explanation
        except to note that all functions defined using it must
        sustain currying and that the namespace model is dual
        (see the document on <strong>porting </strong>for more on
        this). There is no necessity to support nested
        definitions in the manner of Scheme. <strong>defun</strong>
        is a top level construction and there is no obligation to
        support the evaluation of <strong>defun</strong> within
        an expression; this also holds true of <strong>define</strong>
        unless it is used in a package.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>lambda</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>lambda</strong>
        in K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> is deliberately spartan;
        following lambda calculus in defining an abstraction that
        accepts only one argument. <strong>let</strong> is
        strictly otiose being definable by the equation.</font></p>
        <p align="left"><font size="2" face="Verdana">(let X Y Z)
        = ((lambda X Z) Y)</font></p>
        <p align="left"><font size="2" face="Verdana">However
        this form is less natural and less familiar than the
        traditional local assignment and is not definable except
        by a macro. Note that in Shen (lambda X X) is legal.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>eval-kl</strong></font></p>
        <p align="left"><font size="2" face="Verdana"><strong>eval-kl</strong>
        evaluates a K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> expression. It is generally not
        used within applications programming. The function <strong>eval
        </strong>is not a primitive in K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana">, but
        <strong>eval-kl</strong> is.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>eval</strong>
        in Shen applied to an an expression E returns the
        expression E' that results from evaluating the expression
        E'' where E'' results from E by the replacement of all
        the square brackets in E' by round ones (see </font><a
        href="http://www.lambdassociates.org/Book/page131.htm"><font
        size="2" face="Verdana">www.lambdassociates.org/Book/page131.htm</font></a><font
        size="2" face="Verdana">)</font><font size="2"
        face="Symbol">.</font><font size="2" face="Verdana"> Thus
        (eval [+ 1 2]) evaluates to what (+ 1 2) evaluates to -
        which is 3. </font></p>
        <p align="left"><font size="2" face="Verdana"><strong>freeze
        </strong>and<strong> thaw</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        function <strong>freeze</strong> freezes the computation
        represented by its argument which is not evaluated.
        Effectively <strong>freeze</strong> returns a <em>continuation</em>;
        defined by Wikipedia as &quot;[the reification of] an <i>instance</i>
        of a computational process at a given point in the
        process's execution&quot;. The counterpart to <strong>freeze</strong>
        is the function <strong>thaw</strong> which unfreezes the
        computation and returns the evaluated result. <strong>thaw</strong>
        is not primitive being readily defined in K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> as</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(defun
        thaw (F) (F))</strong></font></p>
        <p align="left"><a name="Type Declarations"></a><font
        size="3" face="Verdana"><strong>Type Declarations</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        primitive<strong> type</strong> is used to annotate any
        s-expression. The notation is </font></p>
        <p align="center"><font size="2" face="Verdana"><strong>(type
        &lt;S-expr&gt; &lt;type&gt;) </strong></font></p>
        <p align="left"><font size="2" face="Verdana">as in<strong>
        (type (+ 1 2) number)</strong>.<strong> </strong>This is
        not in any sense a normal function since the type <strong>&lt;type&gt;</strong>
        is discarded in evaluation (i.e. <strong>(type
        &lt;S-expr&gt; &lt;type&gt;) </strong>evaluates to the
        normal form of <strong>&lt;S-expr&gt;</strong>. The type
        declaration is not ignored by the type checker which
        actually expects the expression to have the type attached
        to it and will signal an error if this is not so. </font></p>
        <p align="left"><font size="2" face="Verdana">The degree
        to which any implementation of K</font><font size="2"
        face="Symbol">l</font><font size="2" face="Verdana"> uses
        the information provided by this annotation will depend
        on the platform and the implementation. Shen 11 and later
        will, if required, automatically generate copious <strong>type</strong>
        annotations in K</font><font size="2" face="Symbol">l</font><font
        size="2" face="Verdana"> which can be used by K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> implementors or platform providers of
        Shen to optimise the resultant code. The command <strong>(optimise
        +)</strong> enables this feature. The default is <strong>(optimise
        -)</strong>.</font></p>
        <p align="left"><font size="2" face="Verdana">Optimisation
        of the type declarations in a type checked Shen function
        F is expected to preserve the I/O features of F only with
        respect to type secure input. Thus </font></p>
        <p align="left"><font size="2" face="Verdana"><strong>(define
        =n<br>
        {number --&gt; number}<br>
        N N -&gt; true<br>
        _ _ -&gt; false)</strong></font></p>
        <p align="left"><font size="2" face="Verdana">may return
        an error on non-numeric inputs when optimised.</font></p>
        <p align="left"><a name="External Global Variables"></a><font
        size="3" face="Verdana"><strong>External Global Variables</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        following variables are external to the Shen package. The
        variable <strong>*language*</strong> is bound to a string
        which indicates the platform under which Shen is running.
        For Common Lisp this is &quot;Common Lisp&quot;. The
        global <strong>*implementation* </strong>is bound to the
        implementation; e.g. &quot;CLisp&quot; and <strong>*release*</strong>
        to the release of the platform e.g. 2.45. <strong>*port*</strong>
        and <strong>*porters*</strong> are bound to the port
        version on that platform and the authors of the port. The
        variable <strong>*stinput*</strong> is bound to the
        standard input stream and <strong>*stoutput*</strong> to
        the standard output stream. <strong>*home-directory* </strong>is
        bound to a string which denotes the directory relative to
        which all files are read or written. <strong>*version*</strong>
        is bound to a string detailing the release of Shen.<strong>
        *maximum-print-sequence-size* </strong>determines the
        maximum size to which a sequence is fully printed. <strong>*macros*
        </strong>contains the list of current macros. <strong>*hush*</strong>
        is bound to a boolean, by default <strong>false</strong>,
        and regulates printing.</font></p>
        <p align="left"><a name="Property Lists and Hashing"></a><font
        size="3" face="Verdana"><strong>Property Vectors and
        Hashing</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Like Qi,
        Shen includes property lists. However they are not
        implemented using CL property lists, but instead rely on
        a hashing function into a standard vector <strong>*property-vector*</strong>
        which is internal to the Shen package and by default set
        to hold 20,000 elements. </font></p>
        <p align="left"><font size="2" face="Verdana">The
        expression <strong>(put Mark sex male)</strong> creates a
        pointer <strong>sex</strong> from <strong>Mark</strong>
        to the object <strong>male</strong>. The expression <strong>(get
        Mark sex)</strong> retrieves <strong>male</strong>. If no
        pointer exists from the object then <strong>get</strong>
        returns an error.</font></p>
        <p align="left"><font size="2" face="Verdana">The
        functions <strong>put</strong> and <strong>get</strong>
        index into the vector by converting their first argument
        A into a number via the hashing function (see below) that
        involves summing the code point values of constituent
        components of A. This hashing function </font><font
        size="2" face="Symbol">h</font><font size="2"
        face="Verdana"> may be a many-one function, hence <strong>*property-vector*</strong>
        is a vector of lists and a list search is used at
        position (</font><font size="2" face="Symbol">h</font><font
        size="2" face="Verdana"> A) in V to locate the correct
        value. Current performance for hash coding an object is
        16,000 hashes per second under CLisp using a 1.3 Ghz
        Pentium for a 10-character object. This function is
        subject to any improvements and changes that are
        consistent with the language specification (see <strong>optimising
        the system functions </strong>in the document on
        porting).</font></p>
        <p align="left"><font size="2" face="Verdana">In Qi, <strong>get-prop</strong>
        was a 3-place function (get-prop X P Y) where the third
        argument was returned if no pointer P existed from X. In
        Shen, if no pointer exists then an error is returned.
        Using exception handling, assuming X and P are
        well-defined, <strong>get-prop</strong> is easily defined
        in Shen.</font></p>
        <p align="left"><font size="2" face="Verdana">(get-prop X
        P Y) = (trap-error (get X P) (/. E Y))</font></p>
        <p align="left"><font size="2" face="Verdana">Unline CL,
        arguments to <strong>get</strong> and <strong>put</strong>
        can be objects of any type provided their constituents
        are representable within the default string set. If the
        hash value (</font><font size="2" face="Symbol">h</font><font
        size="2" face="Verdana"> A) of the argument A exceeds the
        limit of the property list vector, the modulus M of (</font><font
        size="2" face="Symbol">h</font><font size="2"
        face="Verdana"> A) to the size of the vector is taken and
        the data is placed in the Mth address of the vector.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>put</strong>
        and <strong>get</strong> are actually polyadic functions
        which appear as such by the grace of the Shen reader.
        There is an optional final argument which should be a
        standard vector; thus <strong>(put Mark sex male (value
        *myvector*))</strong> will use the vector <strong>*myvector*</strong>
        as the hashing table. If the optional argument is missing
        then <strong>*property-vector* </strong>is used.</font></p>
        <p align="left"><font size="2" face="Verdana">In version
        17 <strong>unput</strong> was introduced which cancels
        the effect of <strong>put</strong>. <strong>(unput Mark
        sex) </strong>will remove the pointer. Again this
        function allows for an optional vector argument which
        defaults unless specified otherwise to the property
        vector.</font></p>
        <p align="left"><font size="2" face="Verdana">The hash
        function <strong>hash </strong>takes as arguments a Shen
        object X and a positive number N (which need not be
        whole) and returns a number M between zero and N, where M
        represents the hash value of X within that interval. </font></p>
        <p align="left"><a name="Error Handling"></a><font
        size="3" face="Verdana"><strong>Error Handling</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The basic
        error function is <strong>simple-error</strong> which
        takes a string and returns it as an exception. A more
        useful version is <strong>error</strong> which, as in Qi
        II, shares the same syntax as <strong>output</strong>,
        except that object returned is an exception. Shen
        includes a basic type secure exception handling mechanism
        drawn from the Qi library called <strong>trap-error</strong>.
        <strong>trap-error</strong> receives two arguments, an
        expression E and a function F. If E evaluates to normal
        form E<em>'</em>, then E<em>'</em> is returned. If an
        exception C is raised it is sent to F and (F C) is
        returned. The function <strong>error-to-string</strong>
        allows exceptions to be turned into strings and printed
        or examined. This function is defined only for exceptions
        and should return an error for any other type of object.</font></p>
        <p align="left"><font size="2" face="Verdana">Note that <strong>trap-error</strong>
        is type secure and its type is</font><font
        color="#000000" size="2" face="Verdana"> A --&gt;
        (exception --&gt; A) --&gt; A. </font></p>
        <p align="left"><font size="2" face="Verdana">Some
        examples</font></p>
        <p><font size="2" face="Verdana"><strong>(trap-error (/ 1
        0) (/. E -1))</strong> gives <strong>-1 : number</strong></font></p>
        <p><font size="2" face="Verdana"><strong>(trap-error (/ 1
        0) (/. E (error-to-string E)))</strong> gives the error
        message as a string &quot;<strong>division by zero&quot;</strong>.</font></p>
        <p align="left"><a name="Numbers"></a><font size="3"
        face="Verdana"><strong>Numbers</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The numbers
        in Shen are as follows.</font></p>
        <p align="left"><font size="2" face="Verdana">1. Numbers
        may be positive or negative or zero.<br>
        2. Numbers are either integers or floats; there are no
        rationals or complex numbers.<br>
        3. E number notation is allowed. They are not part of K</font><font
        size="2" face="Symbol">l</font><font size="2"
        face="Verdana"> but are parsed by the Shen reader to
        integers or floats.<br>
        4. +,-,/,* are 2-place and operate on floats and
        integers. / applied to two integers A and B produces an
        integer if B is a divisor of A otherwise a float.<br>
        5. &gt;=, &lt;, &lt;=, &gt;, = operate over all numbers
        (&gt; 3.5 3) is meaningful and true. (= 1 1.0) is true.<br>
        6. The maximum size of any integer or float and the
        precision of the arithmetic is implementation dependent.</font></p>
        <p align="left"><font size="2" face="Verdana">The BNF is</font></p>
        <p align="left"><font size="2" face="Verdana">&lt;number&gt;
        := &lt;integer&gt; | &lt;float&gt; | &lt;e-number&gt; |
        &lt;sign&gt; &lt;number&gt;<br>
        &lt;integer&gt; := &lt;digit&gt; | &lt;digit&gt;
        &lt;integer&gt;<br>
        &lt;digit&gt; := 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0<br>
        &lt;float&gt; := &lt;integer&gt; . &lt;integer&gt; | .
        &lt;integer&gt;<br>
        &lt;e-number&gt; := &lt;integer&gt; e &lt;integer&gt; |
        &lt;float&gt; e &lt;integer&gt; | &lt;integer&gt; e
        -&lt;integer&gt; | &lt;float&gt; e -&lt;integer&gt; <br>
        &lt;sign&gt; := </font><font size="2" face="Symbol">+ </font><font
        size="2" face="Verdana">| - | + &lt;sign&gt; | -
        &lt;sign&gt; </font></p>
        <p align="left"><font size="2" face="Verdana">This is
        deliberately kept simple. There is no distinction between
        bignums, fixnums etc. There is already a <strong>standard
        maths library</strong> developed by Dr Willi Riha which
        will load in a range of numeric functions including
        trigonometric functions. There may be packages which
        offer a richer range of types for numbers (fixnum and
        bignum etc.) with much greater scope for optimisation
        within the compiler and which are platform specific.
        However these will be plugins, not in the language
        standard or in the standard maths library. </font></p>
        <p align="left"><font size="2" face="Verdana">Shen uses
        simple cancellation when reading signs; thus --3 is read
        as 3 and ---3 as -3. +3 is just 3. Note (- 3) returns a
        closure that subtracts its argument from 3. Any fronting
        number is treated as a token; so for instance [f 5a] will
        be parsed as [f 5 a] (since 5a cannot be a symbol).</font></p>
        <p align="left"><font size="2" face="Verdana">The maximum
        size of any number and the precision of the arithmetic
        are platform dependent. However the minimum of double
        precision is <strong>strongly</strong> recommended.</font></p>
        <p align="left"><font size="2" face="Verdana">For users
        running Shen on other platforms, it is highly likely that
        the platform has already defined &gt;, +, -, *, /, &lt;,
        &gt;=, =, etc. in a way that is inconsistent with the
        semantics allotted to these symbols in K</font><font
        size="2" face="Symbol">l.</font><font size="2"
        face="Verdana"> The .kl sources use these symbols in
        their native dress because implementors wishing to
        implement K</font><font size="2" face="Symbol">l </font><font
        size="2" face="Verdana">will want to use '*' for multiply
        etc. But platform providers compiling .kl sources to
        another language and who experience a name clash with a
        native function, should read carefully the notes on
        porting in the porting document.</font></p>
        <p align="left"><a name="Floats and Integers"></a><font
        size="3" face="Verdana"><strong>Floats and Integers</strong></font></p>
        <p align="left"><font size="2" face="Verdana">Division
        between integers in Shen will yield a float if the
        divisor is not a whole divisor of the numerator. In some
        languages, e.g. Python, (/ 3 2) gives 1 (integer
        division) and not 1.5. It was argued as to whether Shen
        should follow suit. It was felt that in such cases it was
        more intuitive to return an answer with a fractional
        component - most people would consider 3/2 = 1 as false
        and for people using Shen to do wages calculations etc.
        'street' division is more appealing. Integer division has
        been placed in the standard maths library.</font></p>
        <p align="left"><font size="2" face="Verdana">An
        interesting question concerns the comparison of floats
        and integers is (= 1 1.0) true or not? Mathematically the
        decimal notation is simply a shorthand for a sum.</font></p>
        <p align="left"><font size="2" face="Verdana">i.e. 1.0 =
        (1 x 10<sup>0</sup>) + (0 x 10<sup>-1</sup>) = 1</font></p>
        <p align="left"><font size="2" face="Verdana">Therefore
        if = represents identity then (= 1 1.0) is true. In Shen
        (= 1 1.0) <em><u>is</u></em> true (as in Common Lisp, (=
        1 1.0) returns T) and 1.0 entered to the top level is
        returned as 1. Effectively a float is parsed as a sum of
        products i.e. 1.23 = (1 x 10<sup>0</sup>) + (2 x 10<sup>-1</sup>)
        + (3 x 10<sup>-2</sup>). </font></p>
        <p align="left"><font size="2" face="Verdana">E numbers
        are parsed similarly i.e. 1.23e2 = ((1 x 10<sup>0</sup>)
        + (2 x 10<sup>-1</sup>) + (3 x 10<sup>-2</sup>)) x 10<sup>2</sup></font></p>
        <p align="left"><font size="2" face="Verdana">A contrary
        approach is taken in Prolog where '1 = 1.0' is false. In
        ML the comparison is meaningless (returns an error)
        because 1.0 and 1 belong to different types - real and
        int. This is wrong. Computing has fogged the issues here
        and committed the traditional error of confusing <em>use</em>
        and <em>mention</em> in its treatment of integers and
        floats, in other words, between numbers and the signs we
        use to represent them. We should not confuse the identity
        of two numbers with the identity of their representation.
        If we want to say that 1.0 is not an integer and 1 is, we
        commit an error, because 1.0 = 1; unless we mean by
        'integer' an expression which is applied to the
        representation itself (as in the BNF above) i.e. '1.0'.
        In which case the expression 'integer' is predicated of
        something which is a numeral, in computing terms, a
        string. In Shen, the <strong>integer?</strong> test is
        taken as predicating of numbers and 1.0 is treated as an
        integer.</font></p>
        <p align="left"><font size="2" face="Verdana">The integer
        test in Shen runs in log time and is predicated on the
        following 'equations'</font></p>
        <p align="left"><font size="2" face="Verdana">integer -
        integer = integer<br>
        non-integer - integer = non-integer</font></p>
        <p align="left"><font size="2" face="Verdana">These
        'equations', though mathematically true, can fail outside
        a certain range (commonly beyond 15 digits) which depends
        on the precision of the platform and therefore the
        accuracy of this test depends on the precision of the
        arithmetic. Thus we recommend that Shen be installed with
        at least double precision which gives accuracy up to 15
        digits.</font></p>
        <p align="left"><a name="The Timer"></a><font size="3"
        face="Verdana"><strong>The Timer</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The <strong>get-time</strong>
        function is a 1 place function that returns a floating
        point number. The range of arguments supported by this
        function is implementation dependent as are the results.</font></p>
        <p align="left"><font size="2" face="Verdana">For the
        argument <strong>real</strong> it should return a value
        representing real time i.e. two invocations of this
        function on real time should be seperated by an amount of
        time equal to the difference of their values. As such <strong>get-time</strong>
        can be used to measure the wall time elapsed between
        calls. The exact value of the results returned is
        implementation dependent as are the number of places used
        but the basic unit of measure should be seconds.</font></p>
        <p align="left"><font size="2" face="Verdana">It is
        optional to set this function to record not real time,
        but run time; that is the actual CPU time. The argument <strong>run</strong>
        should return a value that is implementation dependent,
        but the difference between the two invocations of this
        function on run time should be seperated by an amount of
        time equal to the CPU time expended by Shen between the
        two calls. The exact value of the results returned is
        implementation dependent as are the number of places
        used.</font></p>
        <p align="left"><font size="2" face="Verdana">The
        argument <strong>unix</strong> should return a number
        representing UNIX time in seconds i.e. the time elapsed
        since midnight January 1st 1970.</font></p>
        <p align="left"><font size="2" face="Verdana">Note that
        not all platforms may support both <strong>run</strong> <em>and</em>
        <strong>real </strong>but either <strong>run</strong> <em>or</em>
        <strong>real</strong> should be supported. In either case
        the timer function built into Shen should reflect in the
        information provided whether run time or real time is
        being measured. If an argument is not supported then an
        appropriate error should be raised.</font></p>
        <p align="left"><a name="Comments"></a><font size="3"
        face="Verdana"><strong>Comments in Shen</strong></font></p>
        <p align="left"><font size="2" face="Verdana">One flaw in
        Qi II and Qi I was that comments were made using \ .....
        \ which meant that comments could not themselves be
        commented out and the syntax clashed with that for
        characters which also used \. Shen follows the convention
        of starting comments with <strong>\*</strong> and ending
        with <strong>*\</strong>. </font></p>
        <p align="left"><font size="2" face="Verdana">Version 10
        allows for single line comments -\\ will blank out all
        the input before the next RETURN or newline.</font></p>
        <p align="left"><a name="Special Forms"></a><font
        size="3" face="Verdana"><strong>Special Forms</strong></font></p>
        <p align="left"><font size="2" face="Verdana">The
        following are all </font><a
        href="http://www.lambdassociates.org/Book/page272.htm"><font
        size="2" face="Verdana">special forms</font></a><font
        size="2" face="Verdana"> in Shen and have their own
        hard-coded type rules; they are not type checked in
        curried form and do not sustain type secure currying.</font></p>
        <p align="left"><font size="2" face="Verdana"><strong>@p
        @s @v cons lambda let type where input+ define defmacro
        datatype /. synonyms open</strong></font></p>
        </td>
    </tr>
</table>
</center></div>

<p><font color="#0000A0" size="6" face="Edwardian Script ITC">Mark</font></p>

<p><font size="2" face="Verdana">copyright (c) 2013, Dr Mark
Tarver<br>
</font><a href="mailto:dr.mtarver@gmail.com"><font size="2"
face="Verdana">dr.mtarver@gmail.com</font></a></p>
</body>
</html>
